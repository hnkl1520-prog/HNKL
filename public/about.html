<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio - About Hanuk</title>
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/static/pretendard.css" />
    
    <!-- [필수] GSAP 추가 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        :root {
            /* [Color Theme] Light Mode */
            --bg-color: #F5F5F7;
            --text-color: #1D1D1F;
            --accent-color: #2997ff; /* Blue */
            --sub-color-1: #9c6dff;  /* Purple */
            --sub-color-2: #4fd1c5;  /* Mint */
            --dim-color: #86868b;
            --text-sub: #6e6e73;
            --card-bg: #FFFFFF;
        }

        body, html {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Pretendard', sans-serif;
            width: 100%;
            cursor: default;
            
            /* 텍스트 렌더링 품질 개선 */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        /* =========================================
            HEADER SECTION
            ========================================= */
        #global-header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            z-index: 900; 
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(245, 245, 247, 0.7); 
            backdrop-filter: blur(10px); 
            border-bottom: 1px solid rgba(0,0,0,0.05);
            transition: transform 0.3s ease, background-color 0.3s ease, height 0.3s ease, border-bottom 0.3s ease;
        }

        #global-header.at-top {
            height: 90px; 
            background-color: rgba(245, 245, 247, 0); 
            border-bottom: 1px solid rgba(0,0,0,0); 
        }

        #global-header.header-hidden {
            transform: translateY(-100%);
        }

        .header-inner {
            width: 100%;
            max-width: 1200px;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            height: 100%; 
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 40px; 
        }

        .header-logo {
            display: flex;
            align-items: center;
            text-decoration: none;
        }
        
        .header-logo img {
            height: 24px; 
            width: auto;
            display: block;
            transition: height 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
            will-change: height; 
        }

        #global-header.at-top .header-logo img {
            height: 31px; 
        }

        .header-nav {
            display: flex;
            gap: 24px;
            transition: transform 0.3s ease;
        }

        .nav-link {
            font-size: 1.1rem; 
            color: var(--text-sub);
            text-decoration: none;
            font-weight: 500;
            position: relative;
            transition: color 0.2s;
        }

        .nav-link:hover {
            color: var(--text-color);
        }

        .nav-link.active {
            color: var(--text-color);
            font-weight: 600;
        }
        .nav-link.active::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: -4px;
            width: 100%;
            height: 2px;
            background-color: var(--text-color);
            border-radius: 2px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
            font-weight: 500;
        }

        .lang-btn {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: var(--text-sub);
            font-family: 'Pretendard', sans-serif;
            font-size: inherit;
            transition: color 0.2s;
        }
        
        .lang-btn.active {
            color: var(--text-color);
            font-weight: 700;
        }
        
        .lang-btn:hover {
            color: var(--accent-color);
        }

        .lang-divider {
            color: var(--dim-color);
            opacity: 0.5;
        }

        #page-entry-curtain {
            position: fixed;
            top: 0; 
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 99998; 
        }

        #loading-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: transparent; 
            z-index: 99999; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.6s ease, visibility 0.6s ease;
        }
        
        #loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loading-text {
            font-size: 1.2rem;
            font-weight: 500;
            color: #ffffff; 
            margin-bottom: 10px;
            letter-spacing: -0.01em;
        }

        .loading-bar-bg {
            width: 200px;
            height: 2px;
            background-color: #333; 
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .loading-bar-fill {
            width: 0%;
            height: 100%;
            background-color: var(--accent-color);
            transition: width 0.2s linear;
        }

        .menu-item, .win-btn, #chat-minimized-icon, button, .send-btn, a, .skill-item, .bento-card, .circle-btn, .profile-card, .marquee-item, .lang-btn, .nav-link, .header-logo { cursor: pointer; }

        /* [최종 해결] 커서 레이어 분리 및 블렌딩 모드 제어 */
        
        /* 레이어 1: 원 (배경 반전용) */
        #cursor-bg-layer {
            position: fixed; top: 0; left: 0;
            width: 0; height: 0; 
            z-index: 9990; /* 텍스트 레이어보다 아래 */
            pointer-events: none;
            will-change: transform;
            display: flex; align-items: center; justify-content: center;
            
            /* [수정] 평소에는 반전 효과 끔 (그라데이션 색상 유지) */
            mix-blend-mode: normal; 
        }

        /* [수정] 호버 시에만 반전 효과 적용 */
        #cursor-bg-layer.active-enter {
            mix-blend-mode: difference; 
        }

        #cursor-circle {
            position: absolute;
            width: 40px; height: 40px;
            border-radius: 50%;
            
            /* 기본 상태: 그라데이션 */
            background: linear-gradient(120deg, var(--accent-color), var(--sub-color-1), var(--sub-color-2), var(--accent-color));
            background-size: 300% 300%;
            animation: gradientCursor 4s ease infinite; 
            opacity: 0.6; 
            
            transform-origin: center center;
            transition: width 0.3s cubic-bezier(0.19, 1, 0.22, 1),
                        height 0.3s cubic-bezier(0.19, 1, 0.22, 1),
                        background-color 0.3s, margin 0.3s, opacity 0.3s;
        }

        /* 호버 시: 원을 흰색으로 변경 (흰색 + difference = 반전 효과) */
        #cursor-bg-layer.active-enter #cursor-circle {
            width: 120px; height: 120px;
            background: #ffffff; /* 흰색이어야 반전이 확실하게 일어남 */
            opacity: 1;
            animation: none;
        }

        /* 레이어 2: 텍스트 (그냥 위에 얹음, 블렌딩 없음) */
        #cursor-text-layer {
            position: fixed; top: 0; left: 0;
            width: 0; height: 0; 
            z-index: 9995; /* 원보다 위에 있어야 함 */
            pointer-events: none;
            will-change: transform;
            display: flex; align-items: center; justify-content: center;
            
            /* 블렌딩 모드 없음 (Normal) */
            mix-blend-mode: normal; 
        }

        #cursor-text {
            position: absolute; 
            /* 중앙 정렬 */
            top: 50%; left: 50%;
            transform: translate(-50%, -50%); 
            
            font-size: 24px; font-weight: 500; 
            color: #ffffff; /* 깔끔한 흰색 텍스트 */
            opacity: 0; 
            white-space: nowrap; 
            transition: opacity 0.2s; 
            letter-spacing: 0.05em; 
            -webkit-font-smoothing: antialiased;
        }

        #cursor-text-layer.active-enter #cursor-text {
            opacity: 1;
        }

        @keyframes gradientCursor {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 1200px; margin: 0 auto; padding: 0 20px; box-sizing: border-box;
        }

        #hero-section {
            position: relative; 
            width: 100%; 
            min-height: 100vh; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            background-color: var(--bg-color);
            overflow: hidden; 
            padding-bottom: 160px; 
            box-sizing: border-box;
        }

        .hero-layout-new {
            display: flex;
            flex-direction: column; 
            width: 100%;
            height: 100%;
            justify-content: center; 
            align-items: flex-start; 
            padding-left: 0;
            padding-top: 100px; 
        }

        .hero-text-block {
            text-align: left;
            color: var(--text-color);
            font-size: 3rem;
            line-height: 1.6;
            letter-spacing: -0.01em; 
            font-weight: 300; 
            word-break: keep-all;
            margin-bottom: 0px; 
            width: 100%; 
            z-index: 10; 
            position: relative;
            transform: translateZ(0);
        }

        .profile-card {
            width: 300px;
            height: 400px;
            perspective: 1000px;
            cursor: pointer;
            position: relative;
            transition: transform 0.3s ease;
            z-index: 20;
            align-self: flex-end; 
            margin-top: -55px; 
            -webkit-font-smoothing: subpixel-antialiased;
            backface-visibility: hidden;
            transform-style: preserve-3d;
        }
        .profile-card:hover { transform: translate(2px, -4px); }

        .profile-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.5s ease-out;
            transform-style: preserve-3d;
            border-radius: 24px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
        }
        .profile-card:hover .profile-inner { box-shadow: 0 25px 50px rgba(0,0,0,0.1); }
        .profile-card.flipped .profile-inner { transform: rotateY(180deg); }

        .profile-front, .profile-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 24px;
            overflow: hidden;
            background-color: var(--card-bg);
        }

        .profile-front img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .profile-back { transform: rotateY(180deg); background-color: #000; }
        .profile-video { width: 100%; height: 100%; object-fit: cover; display: block; pointer-events: none; }

        .scroll-indicator {
            position: relative; 
            width: 100%;
            text-align: center;
            font-size: 0.8rem; 
            opacity: 0.5; 
            animation: bounce 2s infinite; 
            z-index: 30;
            color: var(--text-color);
            margin-top: 40px; 
            margin-bottom: 60px; 
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateY(0);}
            40% {transform: translateY(-10px);}
            60% {transform: translateY(-5px);}
        }

        @media (max-width: 1024px) {
            .hero-layout-new { align-items: center; }
            .hero-text-block { text-align: center; font-size: 2.5rem; margin-bottom: 40px; }
            .profile-card { align-self: center; margin-top: 0px; }
        }
        @media (max-width: 768px) {
            .hero-text-block { font-size: 1.8rem; }
            .profile-card { width: 280px; height: 373px; }
        }

        #image-marquee-section {
            width: 100%;
            height: 70vh; 
            min-height: 600px; 
            background-color: var(--bg-color);
            position: relative; 
            overflow: hidden;
            padding: 100px 0; 
            box-sizing: border-box;
            touch-action: none; 
        }

        .marquee-track-wrapper {
            position: absolute; 
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; align-items: flex-start; 
            overflow: hidden;
            pointer-events: none; 
            padding-top: 0; 
            transition: z-index 0.3s; 
        }

        .marquee-track {
            display: flex; align-items: flex-start; 
            width: max-content;
            animation: marquee-scroll 60s linear infinite; 
            will-change: transform;
        }

        .track-1 { animation-duration: 300s; z-index: 1; }
        .track-2 { animation-duration: 340s; z-index: 2; margin-left: -15vw;} 
        .track-3 { animation-duration: 320s; z-index: 3; margin-left: -5vw;} 

        @keyframes marquee-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); } 
        }

        .marquee-item-wrapper {
            flex-shrink: 0;
            position: relative; 
            pointer-events: auto;
            user-select: none;
            -webkit-user-drag: none;
            will-change: transform;
            transition: z-index 0.2s;
        }

        .marquee-item {
            width: 100%; height: 100%;
            border-radius: 24px;
            overflow: hidden;
            background-color: #e0e0e0; 
            position: relative;
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s ease;
            transform-origin: center center;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        
        .marquee-item img {
            width: auto; height: 100%;
            object-fit: cover; display: block;
            min-width: 100px; 
            pointer-events: none; 
        }

        .marquee-item-wrapper:hover .marquee-item {
            transform: scale(1.15); 
            box-shadow: 0 25px 50px rgba(0,0,0,0.25);
        }
        
        .marquee-item-wrapper.dragging .marquee-item {
            cursor: grabbing;
            box-shadow: 0 30px 60px rgba(0,0,0,0.3);
            transform: scale(1.05); 
        }

        @media (max-width: 768px) {
            #image-marquee-section { height: 60vh; min-height: 500px; }
        }

        #philosophy-section { 
            position: relative; 
            width: 100%; 
            height: 400vh; 
            background-color: var(--bg-color);
        }
        
        .philo-container { 
            position: sticky; 
            top: 0;
            width: 100%; 
            max-width: 1200px; 
            margin: 0 auto;
            height: 100vh; 
            display: flex;
            overflow: hidden; 
        }

        .text-col { 
            width: 35%; 
            margin-left: 15%; 
            padding-right: 50px; 
            box-sizing: border-box; 
            z-index: 10; 
            position: relative; 
            display: flex;
            align-items: center; 
        }

        .text-block {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            transform: translateY(-50%);
            background-color: transparent; 
            padding: 0; 
            opacity: 0; 
            pointer-events: none; 
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .philo-intro-title {
            font-size: 4rem; 
            font-weight: 300; 
            line-height: 1;    
            color: var(--text-color); margin-bottom: 20px;
            letter-spacing: -0.02em;
        }
        .philo-intro-sub {
            font-size: 2rem; color: var(--accent-color);
            font-weight: 300;
        }
        
        .philo-label {
            color: var(--accent-color); font-size: 3.0rem; font-weight: 600;
            text-transform: uppercase; letter-spacing: 2px; margin-bottom: 0px; display: block;
        }
        .philo-desc { font-size: 1.5rem; line-height: 1.5; font-weight: 400; word-break: keep-all; color: var(--text-color); margin-top: 12px; }

        .visual-col {
            width: 50%; 
            height: 100vh; 
            display: flex; align-items: center; justify-content: center;
        }
        #three-canvas { width: 100%; height: 100%; outline: none; }

        #key-detail-section {
            padding: 100px 0 200px 0;
            background-color: var(--bg-color);
            position: relative;
            z-index: 10;
        }

        .key-detail-title {
            font-size: 5rem; 
            font-weight: 300; 
            margin-bottom: 60px;
            color: var(--text-color); 
            line-height: 1; 
            text-align: left; 
        }

        .bento-grid {
            display: grid; grid-template-columns: repeat(4, 290px);
            gap: 10px; justify-content: center; align-items: start;
        }

        .col-stack { display: flex; flex-direction: column; gap: 10px; }

        .bento-card {
            background-color: transparent; perspective: 1000px; width: 290px;
            position: relative; transition: transform 0.3s ease; cursor: pointer;
            transform: translateZ(0); 
            -webkit-font-smoothing: subpixel-antialiased; 
        }
        .bento-card:hover { transform: translateY(-5px); }
        .bento-card.card-language { cursor: default; }
        .bento-card.card-language:hover { transform: none; }

        .card-inner {
            position: relative; width: 100%; height: 100%; text-align: left;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-style: preserve-3d; border-radius: 24px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.02);
            will-change: transform;
        }
        .bento-card:hover .card-inner { box-shadow: 0 10px 30px rgba(0,0,0,0.05); }
        .bento-card.flipped .card-inner { transform: rotateY(180deg); }

        .card-front, .card-back {
            position: absolute; width: 100%; height: 100%;
            -webkit-backface-visibility: hidden; backface-visibility: hidden;
            background-color: var(--card-bg); border-radius: 24px;
            padding: 30px; box-sizing: border-box; display: flex; flex-direction: column;
            transform: translateZ(0);
            text-shadow: 0 0 0 transparent; 
        }
        .card-back { transform: rotateY(180deg); overflow: hidden; }

        .card-title { font-size: 2rem; font-weight: 600; margin: 0 0 30px 0; color: var(--text-color); letter-spacing: -0.02em; }
        .sub-card-title { font-size: 1.5rem; font-weight: 600; margin: 0 0 20px 0; color: var(--text-color); }
        .item-main-text { font-size: 1rem; font-weight: 600; color: var(--text-color); margin-bottom: 12px; }
        .item-sub-text { font-size: 12px; font-weight: 400; color: var(--text-sub); margin-bottom: 0px; line-height: 1.2; }
        .date-text { font-size: 12px; font-weight: 400; color: var(--text-color); margin-top: 10px; display: block; }

        .f-600-12 { font-weight: 600; font-size: 12px; color: var(--text-color); }
        .f-400-12 { font-weight: 400; font-size: 12px; color: var(--text-sub); }
        .f-600-10 { font-weight: 600; font-size: 10px; color: var(--text-color); }
        .f-400-10 { font-weight: 400; font-size: 10px; color: var(--text-sub); }
        .mb-4 { margin-bottom: 4px; }
        .mb-8 { margin-bottom: 8px; }

        .card-education { height: 360px; }
        .edu-content { margin-top: auto; }
        .edu-back-list { display: flex; flex-direction: column; gap: 15px; height: 100%; }
        .edu-section-title { font-weight: 600; font-size: 12px; color: var(--accent-color); margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #eee; }
        .edu-row { display: flex; gap: 10px; align-items: flex-start; }
        .edu-year-col { width: 30px; flex-shrink: 0; display: flex; flex-direction: column; gap: 4px; }
        .edu-desc-col { flex: 1; display: flex; flex-direction: column; gap: 4px; }

        .card-language { height: 100px; }
        .lang-list { display: flex; flex-direction: column; gap: 2px; }
        .lang-item { display: flex; justify-content: flex-start; align-items: center; gap: 8px; }
        .lang-name { font-size: 12px; font-weight: 600; }
        .lang-level { font-size: 12px; font-weight: 400; color: var(--text-sub); }

        .card-experience { height: 250px; }
        .exp-content { margin-top: auto; }
        .exp-back-content { display: flex; flex-direction: column; gap: 16px; margin-top: auto; }
        .exp-block { display: flex; flex-direction: column; gap: 2px; }

        .card-capabilities { height: 360px; }
        .capa-list { display: flex; flex-direction: column; gap: 5px; margin-top: auto; align-items: flex-start; }
        .capa-row { display: flex; gap: 5px; }
        .capa-tag { font-size: 1rem; font-weight: 400; color: var(--text-color); border: 1px solid var(--text-color); padding: 6px 10px; border-radius: 999px; transition: all 0.2s; }
        .capa-tag:hover { border-color: var(--accent-color); color: var(--accent-color); }
        .tools-vertical-list { display: flex; flex-direction: column; gap: 16px; margin-top: auto; }
        .tool-row-v { display: flex; flex-direction: column; gap: 4px; }
        .tool-cat-v { font-size: 12px; font-weight: 600; color: var(--text-color); }
        .tool-items-v { font-size: 12px; font-weight: 400; color: var(--text-sub); line-height: 1.3; }

        .card-connect { height: 200px; }
        .connect-front-list { display: flex; flex-direction: column; gap: 4px; margin-top: auto; }
        .contact-back-content { display: flex; flex-direction: column; gap: 16px; margin-top: auto; }
        .contact-block { display: flex; flex-direction: column; gap: 2px; }
        .contact-link { text-decoration: none; color: var(--accent-color); transition: opacity 0.2s; }
        .contact-link:hover { opacity: 0.7; }

        .circle-wrapper { width: 290px; height: 150px; display: flex; justify-content: flex-end; }
        .circle-btn { 
            width: 150px; height: 150px; border-radius: 50%; 
            background-color: var(--card-bg); 
            display: flex; align-items: center; justify-content: center; flex-direction: column; 
            transition: all 0.3s; border: 1px solid transparent; text-decoration: none; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.02); 
            transform: translateZ(0);
        }
        .circle-btn:hover { 
            transform: scale(1.05); 
            background: linear-gradient(135deg, var(--accent-color), var(--sub-color-1));
            border-color: transparent; 
            box-shadow: 0 10px 20px rgba(41, 151, 255, 0.25); 
        }
        .circle-arrow { 
            width: 75px; height: 75px; margin-top: 5px; 
            -webkit-mask: url('assets/Go_2.svg') no-repeat center / contain; 
            mask: url('assets/Go_2.svg') no-repeat center / contain; 
            background-color: var(--text-color); 
            transition: transform 0.3s ease, background-color 0.3s ease; 
        }
        .circle-btn:hover .circle-arrow { 
            transform: translate(3px, -3px); 
            background-color: #ffffff; 
        }

        .footer { text-align: center; padding: 50px 20px; border-top: 1px solid #eee; background-color: #fff; margin-top: 100px; }
        .contact-simple { font-size: 0.9rem; color: var(--dim-color); }
    </style>
</head>
<body>

    <!-- GLOBAL HEADER -->
    <header id="global-header" class="at-top">
        <div class="header-inner">
            <div class="header-left">
                <!-- Logo -->
                <a href="index.html" class="header-logo">
                    <img src="assets/logo.svg" alt="HANUK Logo">
                </a>
                
                <!-- Navigation -->
                <nav class="header-nav">
                    <a href="#" class="nav-link active">About</a>
                    <a href="works.html" class="nav-link">Works</a>
                </nav>
            </div>
            
            <div class="header-right">
                <!-- Language Toggle -->
                <button class="lang-btn active">KR</button>
                <span class="lang-divider">/</span>
                <button class="lang-btn">EN</button>
            </div>
        </div>
    </header>

    <div id="page-entry-curtain"></div>

    <div id="loading-screen">
        <div class="loading-text"><span id="loading-percent">0</span>%</div>
        <div class="loading-bar-bg">
            <div class="loading-bar-fill" id="loading-bar"></div>
        </div>
    </div>

    <!-- [수정] 레이어 분리: 1. 배경용 원 (Difference) -->
    <div id="cursor-bg-layer">
        <div id="cursor-circle"></div>
    </div>

    <!-- [수정] 레이어 분리: 2. 텍스트 (Normal, 상위 레이어) -->
    <div id="cursor-text-layer">
        <span id="cursor-text"></span>
    </div>

    <!-- HERO SECTION -->
    <section id="hero-section">
        <div class="container hero-layout-new">
            <div class="hero-text-block">
                안녕하세요,<br>
                사람과 기술. 사용자와 서비스.<br>
                그 사이를 잇고, 밀도높은 경험을 만드는<br>
                UX·인터랙션 디자이너 이한욱입니다.
            </div>
            <!-- Profile Card -->
            <div class="profile-card" onclick="toggleProfile(this)">
                <div class="profile-inner">
                    <div class="profile-front">
                        <img src="assets/Profile_Photo.png" alt="Hanuk Profile" onerror="this.style.display='none'; this.parentNode.style.backgroundColor='#e0e0e0'">
                    </div>
                    <div class="profile-back">
                        <video class="profile-video" autoplay loop muted playsinline>
                            <source src="assets/Profile_Video.mp4" type="video/mp4">
                        </video>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- NEW: IMAGE MARQUEE SECTION -->
    <section id="image-marquee-section">
        <!-- JS가 트랙을 생성합니다 -->
    </section>

    <div class="scroll-indicator">SCROLL DOWN</div>

    <!-- PHILOSOPHY SECTION -->
    <section id="philosophy-section">
        <div class="philo-container">
            <div class="text-col">
                <div class="text-block" id="philo-text-intro">
                    <h2 class="philo-intro-title">My Approach</h2>
                    
                </div>
                
                <div class="text-block" id="philo-text-1">
                    <span class="philo-label">01.</span>
                    <p class="philo-desc">
                        일상과 데이터 이면의 진짜 니즈를<br>
                        파악하여 문제를 정의합니다. <br>
                        심미성 이전에 <strong>논리적 타당성</strong>을<br>
                        먼저 고민합니다.
                    </p>
                </div>
                <div class="text-block" id="philo-text-2">
                    <span class="philo-label">02.</span>
                    <p class="philo-desc">
                        이를 바탕으로 도출한<br>
                        인사이트와 아이디어를<br>
                        감각적이고 <strong>완성도 높은 비주얼</strong>로<br>
                        표현해냅니다.
                    </p>
                </div>
                <div class="text-block" id="philo-text-3">
                    <span class="philo-label">03.</span>
                    <p class="philo-desc">
                        정적인 화면에 머무르지 않고,<br>
                        <strong>입체적인 인터랙션</strong>으로 구현하여<br>
                        즐거운 경험으로 완성합니다.
                    </p>
                </div>
            </div>
            <div class="visual-col">
                <canvas id="three-canvas"></canvas>
            </div>
        </div>
    </section>

    <!-- KEY DETAIL SECTION -->
    <section id="key-detail-section" >
        <div class="container">
            <h2 class="key-detail-title">Key Info</h2>
            <div class="bento-grid">
                <!-- COL 1 -->
                <div class="bento-card card-education" onclick="toggleFlip(this)">
                    <div class="card-inner">
                        <div class="card-front" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                            <h3 class="card-title">Education</h3>
                            <div class="edu-content">
                                <div class="item-main-text">Hongik University</div>
                                <div class="item-sub-text">Industrial Design Major</div>
                                <div class="item-sub-text">Product & Interaction</div>
                                <span class="date-text">2021.03 - 2025.02</span>
                            </div>
                        </div>
                        <div class="card-back" style="padding: 20px;">
                            <div class="edu-back-list">
                                <div>
                                    <div class="edu-section-title">Exhibitions & Research</div>
                                    <div class="edu-row">
                                        <div class="edu-year-col">
                                            <div class="f-600-10">2024</div>
                                            <div class="f-600-10">2024</div>
                                            <div class="f-600-10">2024</div>
                                        </div>
                                        <div class="edu-desc-col">
                                            <div class="f-400-10">Hongik Industrial Design Degree Show</div>
                                            <div class="f-400-10">AutomotiveUI’24 International Conference</div>
                                            <div class="f-400-10">Zurich Design Week 2024</div>
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <div class="edu-section-title">Industry Collaborations</div>
                                    <div class="edu-row">
                                        <div class="edu-year-col">
                                            <div class="f-600-10">2023</div>
                                            <div class="f-600-10" style="margin-top:12px">2023</div>
                                            <div class="f-600-10" style="margin-top:12px">2023</div>
                                        </div>
                                        <div class="edu-desc-col">
                                            <div>
                                                <div class="f-600-10">Hyundai Motor Group</div>
                                                <div class="f-400-10">Future Mobility UX & Air Conditioning System</div>
                                            </div>
                                            <div>
                                                <div class="f-600-10">University of Zurich (Veterinary Dept.)</div>
                                                <div class="f-400-10">Product for Small Animal</div>
                                            </div>
                                            <div>
                                                <div class="f-600-10">Kolon Glotech</div>
                                                <div class="f-400-10">Autonomous Mobility Lifestyle & CMF</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <div class="edu-section-title">Honors & Activities</div>
                                    <div class="edu-row">
                                        <div class="edu-year-col">
                                            <div class="f-600-10">2024</div>
                                            <div class="f-600-10" style="margin-top:12px">2022<br>-24</div>
                                            <div class="f-600-10" style="margin-top:12px">2022<br>-24</div>
                                        </div>
                                        <div class="edu-desc-col">
                                            <div>
                                                <div class="f-600-10">Patent Application</div>
                                                <div class="f-400-10">Vehicle Air Conditioning & Control System</div>
                                            </div>
                                            <div>
                                                <div class="f-600-10">Industrial Design Student Council</div>
                                                <div class="f-400-10">Head of Graphic Design ('24)</div>
                                            </div>
                                            <div>
                                                <div class="f-600-10">Hongik Central Library</div>
                                                <div class="f-400-10">Institutional Branding & Promotional Visuals</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- COL 2 -->
                <div class="col-stack">
                    <div class="bento-card card-language">
                        <div class="card-inner">
                            <div class="card-front" style="padding-top: 15px; padding-left:20px; padding-bottom:0px; justify-content:center;">
                                <h4 class="sub-card-title" style="margin-bottom: 0; margin-right: 20px;">Language</h4>
                                <div class="lang-list" style="flex:1; justify-content:center;">
                                    <div class="lang-item">
                                        <span class="lang-name">Korean</span>
                                        <span class="lang-level">Native</span>
                                    </div>
                                    <div class="lang-item">
                                        <span class="lang-name">English</span>
                                        <span class="lang-level">Fluent</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="bento-card card-experience" onclick="toggleFlip(this)">
                        <div class="card-inner">
                            <div class="card-front" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                                <h3 class="card-title">Experience</h3>
                                <div class="exp-content">
                                    <div class="item-main-text">Cheil Worldwide</div>
                                    <div class="item-sub-text">Global Samsung Retail Store</div>
                                    <div class="item-sub-text">Device Experience App Content Planning</div>
                                    <div class="item-sub-text">Freelance</div>
                                    <span class="date-text">2025.02 - Present</span>
                                </div>
                            </div>
                            <div class="card-back" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                                <h3 class="card-title">Experience</h3>
                                <div class="exp-back-content">
                                    <div class="exp-block">
                                        <div class="f-600-12">1H 2025</div>
                                        <div class="f-400-12">SmartThings: Galaxy Connected Experience</div>
                                        <div class="f-400-10" style="margin-top:2px;">Designed multi-device UX flows and visual strategies to showcase Galaxy ecosystem connectivity.</div>
                                    </div>
                                    <div class="exp-block">
                                        <div class="f-600-12">2H 2025</div>
                                        <div class="f-400-12">Samsung Mobile Flagship Device Experience</div>
                                        <div class="f-400-10" style="margin-top:2px;">Planned in-app media scenarios and interactive demo content to maximize feature delivery.</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- COL 3 -->
                <div class="bento-card card-capabilities" onclick="toggleFlip(this)">
                    <div class="card-inner">
                        <div class="card-front" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                            <h3 class="card-title">Capabilities</h3>
                            <div class="capa-list">
                                <div class="capa-row">
                                    <div class="capa-tag">UX/UI</div>
                                    <div class="capa-tag">Interaction</div>
                                </div>
                                <div class="capa-row">
                                     <div class="capa-tag">3D</div>
                                     <div class="capa-tag">XR</div>
                                     <div class="capa-tag">Prototyping</div>
                                </div>
                                <div class="capa-row">
                                    <div class="capa-tag">Interactive Web</div>
                                </div>
                            </div>
                        </div>
                        <div class="card-back" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                            <h4 class="sub-card-title">Tools</h4>
                            <div class="tools-vertical-list">
                                <div class="tool-row-v">
                                    <span class="tool-cat-v">3D</span>
                                    <span class="tool-items-v">Blender, Rhino</span>
                                </div>
                                <div class="tool-row-v">
                                    <span class="tool-cat-v">Rendering</span>
                                    <span class="tool-items-v">KeyShot</span>
                                </div>
                                <div class="tool-row-v">
                                    <span class="tool-cat-v">UX/UI & Prototyping</span>
                                    <span class="tool-items-v">Figma, Framer, Unity</span>
                                </div>
                                <div class="tool-row-v">
                                    <span class="tool-cat-v">Adobe</span>
                                    <span class="tool-items-v">Photoshop, Illustrator, Premiere Pro</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- COL 4 -->
                <div class="col-stack">
                    <div class="bento-card card-connect" onclick="toggleFlip(this)">
                        <div class="card-inner">
                            <div class="card-front" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                                <h4 class="sub-card-title">Connect</h4>
                                <div class="connect-front-list">
                                    <div class="f-600-12">Based in</div>
                                    <div class="f-400-12 mb-8">Seoul(KST)</div>
                                    <div class="f-600-12">Flexible</div>
                                    <div class="f-400-12">Happy to discuss the right setup.</div>
                                </div>
                            </div>
                            <div class="card-back" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                                <h4 class="sub-card-title">Contact</h4>
                                <div class="contact-back-content">
                                    <div class="contact-block">
                                        <div class="f-600-12">E-mail</div>
                                        <div class="f-400-12">hnkl1520@gmail.com</div>
                                    </div>
                                    <div class="contact-block">
                                        <div class="f-600-12">Linkedin</div>
                                        <a href="https://www.google.com" target="_blank" class="f-400-12 contact-link">linkedin.com/in/hanuk</a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="circle-wrapper">
                        <a href="works.html" class="circle-btn">
                            <div class="circle-arrow"></div>
                        </a>
                    </div>
                </div>

            </div>
        </div>
    </section>

    <footer class="footer">
        <p class="contact-simple">© 2026 Hanuk Lee. All rights reserved.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Profile Flip
        function toggleProfile(card) {
            if (card.classList.contains('flipped')) {
                card.classList.remove('flipped');
            } else {
                card.classList.add('flipped');
            }
        }

        // Bento Grid Flip
        function toggleFlip(card) {
            if (card.classList.contains('flipped')) {
                card.classList.remove('flipped');
                if (card.flipTimeout) {
                    clearTimeout(card.flipTimeout);
                    card.flipTimeout = null;
                }
            } else {
                card.classList.add('flipped');
                card.flipTimeout = setTimeout(() => {
                    if (card.classList.contains('flipped')) {
                        card.classList.remove('flipped');
                    }
                }, 5000);
            }
        }

        // [수정됨] Custom Jelly Cursor Logic (레이어 분리형)
        (function() {
            // 레이어 1 (원)
            const cursorBgLayer = document.getElementById('cursor-bg-layer');
            const cursorCircle = document.getElementById('cursor-circle'); 
            
            // 레이어 2 (텍스트)
            const cursorTextLayer = document.getElementById('cursor-text-layer');
            const cursorText = document.getElementById('cursor-text');      

            let mouseX = window.innerWidth / 2;
            let mouseY = window.innerHeight / 2;
            let cursorX = mouseX;
            let cursorY = mouseY;
            let velX = 0;
            let velY = 0;

            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                // [NEW] 프로필 카드 내부 호버 로직 (Spatial Detection)
                const profileCard = e.target.closest('.profile-card');
                if (profileCard) {
                    const rect = profileCard.getBoundingClientRect();
                    const relX = e.clientX - rect.left;
                    const relY = e.clientY - rect.top;
                    
                    // Grid 3x3 Logic
                    const colWidth = rect.width / 3;
                    const rowHeight = rect.height / 3;
                    
                    const isCenterCol = relX > colWidth && relX < colWidth * 2;
                    const isBottomTwoRows = relY > rowHeight;
                    
                    if (isCenterCol && isBottomTwoRows) {
                        if (profileCard.classList.contains('flipped')) {
                            cursorText.innerText = "It's also me!";
                        } else {
                            cursorText.innerText = "It's me!";
                        }
                    } else {
                        cursorText.innerText = "Click";
                    }
                }
            });

            function animateCursor() {
                const ease = 0.1; 
                
                const nextX = cursorX + (mouseX - cursorX) * ease;
                const nextY = cursorY + (mouseY - cursorY) * ease;
                
                velX = nextX - cursorX;
                velY = nextY - cursorY;
                cursorX = nextX;
                cursorY = nextY;
                
                const dist = Math.sqrt(velX * velX + velY * velY);
                const angle = Math.atan2(velY, velX);
                
                const stretch = Math.min(dist * 0.1, 0.5); 
                
                const scaleX = 1 + stretch;        
                const scaleY = 1 - stretch * 0.4; 
                
                // 1. 배경 레이어 이동 (원)
                cursorBgLayer.style.transform = `translate3d(${cursorX}px, ${cursorY}px, 0)`;
                // 2. 텍스트 레이어 이동 (동일하게 따라감)
                cursorTextLayer.style.transform = `translate3d(${cursorX}px, ${cursorY}px, 0)`;
                
                // 원의 모양 변형
                cursorCircle.style.transform = `rotate(${angle}rad) scale(${scaleX}, ${scaleY})`;

                requestAnimationFrame(animateCursor);
            }
            animateCursor();

            // [수정됨] 이벤트 위임 (두 레이어 모두 active 클래스 적용)
            document.addEventListener('mouseover', (e) => {
                const target = e.target.closest('a, button, .skill-item, .contact-btn, .bento-card, .circle-btn, .marquee-item, .marquee-item-wrapper, .lang-btn, .nav-link, .header-logo');
                const profileCard = e.target.closest('.profile-card');
                const circleBtn = e.target.closest('.circle-btn');

                if (profileCard) {
                    cursorBgLayer.classList.add('active-enter');
                    cursorTextLayer.classList.add('active-enter');
                } 
                else if (circleBtn) {
                    cursorBgLayer.classList.add('active-enter');
                    cursorTextLayer.classList.add('active-enter');
                    cursorText.innerText = "Works"; 
                }
                else if (target) {
                    cursorBgLayer.classList.add('active-enter');
                    cursorTextLayer.classList.add('active-enter');
                    cursorText.innerText = ""; 
                } 
                else {
                    cursorBgLayer.classList.remove('active-enter');
                    cursorTextLayer.classList.remove('active-enter');
                    cursorText.innerText = "";
                }
            });
            
        })();

        // [New] Scroll Logic for Header & Logo
        (function() {
            let lastScrollY = 0;
            const header = document.getElementById('global-header');
            const heroText = document.querySelector('.hero-text-block');

            // [NEW] 스크롤 임계값 동적 계산 (히어로 텍스트 위치 기준)
            let hideThreshold = 0;
            
            function updateThreshold() {
                if(heroText) {
                    // 헤더 높이만큼 뺀 위치나, 텍스트 상단 위치에서 숨기기 시작
                    hideThreshold = Math.max(50, heroText.offsetTop - 100); 
                } else {
                    hideThreshold = 100; // fallback
                }
            }
            
            updateThreshold();
            window.addEventListener('resize', updateThreshold);

            window.addEventListener('scroll', () => {
                const currentScrollY = window.scrollY;

                // 1. Logo Resize & Header Height Logic (At Top)
                if (currentScrollY <= 10) {
                    header.classList.add('at-top');
                } else {
                    header.classList.remove('at-top');
                }

                // 2. Header Hide/Show Logic
                if (currentScrollY > hideThreshold) {
                    if (currentScrollY > lastScrollY) {
                        // 스크롤 내림 -> 헤더 숨김
                        header.classList.add('header-hidden');
                    } else {
                        // 스크롤 올림 -> 헤더 보임
                        header.classList.remove('header-hidden');
                    }
                } else {
                    // 최상단 근처에서는 항상 보임
                    header.classList.remove('header-hidden');
                }

                lastScrollY = currentScrollY <= 0 ? 0 : currentScrollY;
            });
        })();

        // 3D Logic + Scroll
        (function() {
            const canvas = document.querySelector('#three-canvas');
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            
            let width = document.querySelector('.visual-col').clientWidth;
            let height = window.innerHeight;
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);

            const scene = new THREE.Scene();
            
            const aspect = width / height;
            const frustumSize = 15.0; 
            const camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2,
                frustumSize * aspect / 2,
                frustumSize / 2,
                frustumSize / -2,
                0.1,
                100
            );
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const point = new THREE.PointLight(0x2997ff, 0.8);
            point.position.set(5, 5, 5);
            scene.add(point);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(-5, 5, 2);
            scene.add(dirLight);

            const group = new THREE.Group();
            scene.add(group);

            // [MODIFIED] 1. POINTS & LINES (Animated Drawing)
            const TOTAL_SIZE = 2.2;
            const boxGeo = new THREE.BoxGeometry(TOTAL_SIZE, TOTAL_SIZE, TOTAL_SIZE);
            
            // 1-1. Dot Cube (Vertices)
            const dotGeo = new THREE.BufferGeometry();
            const vertices = [];
            const posAttr = boxGeo.attributes.position;
            for(let i=0; i<posAttr.count; i++){
                vertices.push(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i));
            }
            dotGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const dotMat = new THREE.PointsMaterial({ color: 0x2997ff, size: 0.15 });
            const dotCube = new THREE.Points(dotGeo, dotMat);
            group.add(dotCube);

            // 1-2. Line Cube (Animated Edges)
            const edgesGeo = new THREE.EdgesGeometry(boxGeo);
            const lineMat = new THREE.LineDashedMaterial({ 
                color: 0x2997ff, 
                dashSize: 0, 
                gapSize: 1000, 
                transparent: true, 
                opacity: 0.9 
            });
            const lineCube = new THREE.LineSegments(edgesGeo, lineMat);
            lineCube.computeLineDistances();
            group.add(lineCube);

            // 1-3. Solid Cube (Existing)
            const solidMat = new THREE.MeshPhysicalMaterial({
                color: 0x2997ff, metalness: 0.0, roughness: 1.0, 
                transparent: true, opacity: 0 
            });
            const solidCube = new THREE.Mesh(boxGeo, solidMat);
            group.add(solidCube);

            // 2. CLONER SETS (Explosion)
            const unitGeo = new THREE.BoxGeometry(1, 1, 1);
            const clonerMat = new THREE.MeshPhysicalMaterial({
                color: 0xe0e0e0, metalness: 0.0, roughness: 1.0
            });

            function createSet(gridCnt, colorOrType, baseScale, targetScale, layoutType='standard') {
                const count = gridCnt ** 3;
                const mesh = new THREE.InstancedMesh(unitGeo, clonerMat, count);
                const data = [];
                const dummy = new THREE.Object3D();
                const unitSize = TOTAL_SIZE / gridCnt;
                const gap = unitSize * 1.05; 
                const purpleColor = new THREE.Color(0x9c6dff);
                const mintColor = new THREE.Color(0x4fd1c5);
                const baseColor = new THREE.Color(0xe0e0e0);
                const maxDist = Math.sqrt(3 * Math.pow((gridCnt-1)/2, 2));

                let idx = 0;
                for(let x=0; x<gridCnt; x++){
                    for(let y=0; y<gridCnt; y++){
                        for(let z=0; z<gridCnt; z++){
                            let ix = x - (gridCnt-1)/2;
                            let iy = y - (gridCnt-1)/2;
                            let iz = z - (gridCnt-1)/2;
                            let pos = new THREE.Vector3(ix, iy, iz);
                            if (layoutType === 'rotated') pos.set(-iy, ix, iz); 
                            else if (layoutType === 'standard') pos.addScalar(0.2); 
                            
                            data.push({
                                ix: pos.x, iy: pos.y, iz: pos.z, 
                                gap,        
                                visualBase: baseScale.clone().multiplyScalar(0.9), 
                                visualTarget: targetScale.clone().multiplyScalar(0.9),
                                unitSize,
                                randPhase: Math.random() * 100
                            });

                            dummy.position.set(0,0,0);
                            dummy.scale.set(0,0,0);
                            dummy.updateMatrix();
                            mesh.setMatrixAt(idx, dummy.matrix);
                            
                            const dist = Math.sqrt(ix*ix + iy*iy + iz*iz);
                            const alpha = Math.min(1, dist / maxDist);

                            if (colorOrType === 'purple_gradient') {
                                const t = alpha * alpha; 
                                const c = baseColor.clone().lerp(purpleColor, t);
                                mesh.setColorAt(idx, c);
                            } else if (colorOrType === 'mint_gradient') {
                                const c = mintColor.clone().lerp(baseColor, alpha);
                                mesh.setColorAt(idx, c);
                            } else {
                                mesh.setColorAt(idx, colorOrType);
                            }
                            idx++;
                        }
                    }
                }
                group.add(mesh);
                return { mesh, data, count };
            }

            const set1 = createSet(5, 'purple_gradient', new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.4, 0.6, 0.04), 'rotated');
            const set2 = createSet(5, new THREE.Color(0x2997ff), new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.6, 0.6, 0.6), 'rotated');
            const set3 = createSet(4, 'mint_gradient', new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.15, 1.1, 0.15), 'offset');
            const allSets = [set1, set2, set3];
            allSets.forEach(s => s.mesh.visible = false);

            const clock = new THREE.Clock();
            let state = 0; 
            
            let currentDraw = 0; 
            let targetDraw = 0;  
            
            let tempScale = new THREE.Vector3();
            const dummy = new THREE.Object3D();

            function animate() {
                requestAnimationFrame(animate);
                const time = clock.getElapsedTime() * 0.5;

                // Rotation
                if (state < 0.9) group.rotation.y += 0.005; 
                else group.rotation.y += (Math.PI / 2 - group.rotation.y) * 0.05;

                // [UPDATE] Auto Line Drawing Logic
                currentDraw += (targetDraw - currentDraw) * 0.005;
                
                const maxDash = 100; 
                lineCube.material.dashSize = currentDraw * maxDash;
                
                // 3D Logic (Explosion)
                if(state > 0.9) {
                    const p = Math.max(0, state - 1.0); 
                    const spreadProgress = Math.min(p * 2.0, 1.0); 
                    const spread = 1.0 + (spreadProgress * 0.4);

                    allSets.forEach((set, sIdx) => {
                        let i = 0;
                        for(let data of set.data) {
                            dummy.position.set(
                                data.ix * data.gap * spread,
                                data.iy * data.gap * spread,
                                data.iz * data.gap * spread
                            );
                            const diag = data.ix + data.iy + data.iz; 
                            const val = time * 2.5 - diag - (sIdx * 2.5);
                            let scaleFactor = Math.pow((Math.sin(val) + 1) / 2, 1.5);
                            let animatedScale = new THREE.Vector3().lerpVectors(data.visualBase, data.visualTarget, scaleFactor);
                            const morphProgress = Math.min(p * 1.5, 1.0);
                            const solidLookScale = new THREE.Vector3(data.unitSize, data.unitSize, data.unitSize);
                            tempScale.lerpVectors(solidLookScale, animatedScale, morphProgress);
                            
                            dummy.scale.copy(tempScale);
                            dummy.updateMatrix();
                            set.mesh.setMatrixAt(i, dummy.matrix);
                            i++;
                        }
                        set.mesh.instanceMatrix.needsUpdate = true;
                    });
                } else {
                    if (set1.mesh.visible) {
                        allSets.forEach(set => {
                            let i = 0;
                            for(let data of set.data) {
                                dummy.position.set(data.ix*data.gap, data.iy*data.gap, data.iz*data.gap);
                                dummy.scale.set(data.unitSize, data.unitSize, data.unitSize); 
                                dummy.updateMatrix();
                                set.mesh.setMatrixAt(i, dummy.matrix);
                                i++;
                            }
                            set.mesh.instanceMatrix.needsUpdate = true;
                        });
                    }
                }
                renderer.render(scene, camera);
            }
            animate();

            // SCROLL SYNC
            const section = document.getElementById('philosophy-section');
            const texts = [
                document.getElementById('philo-text-intro'),
                document.getElementById('philo-text-1'),
                document.getElementById('philo-text-2'),
                document.getElementById('philo-text-3')
            ];

            function mapPercentToState(p) {
                // [수정됨] 타이밍 조절
                
                // Phase 1: Wireframe (Intro ~ 01 구간)
                if (p <= 0.40) {
                    return 0; 
                }
                // Phase 2: Solidify (02 구간: 0.40 ~ 0.60)
                else if (p <= 0.60) {
                    return (p - 0.40) / 0.2; 
                }
                // Phase 3: Explode (03 구간: 0.60 이후)
                else {
                    return 1.0 + ((p - 0.60) / 0.40);
                }
            }

            function updateCards(percent) {
                // [수정됨] 스크롤 위치에 따라 0 또는 1로 명확하게 상태 변경 (구간 설정)
                
                // Helper: 텍스트 보임/숨김 처리
                const setVisible = (index, isVisible, direction = 'up') => {
                    const el = texts[index];
                    if (isVisible) {
                        el.style.opacity = 1;
                        el.style.transform = 'translateY(-50%)'; // 정위치
                    } else {
                        el.style.opacity = 0;
                        // 안 보일 때 약간의 위치 이동으로 등장감을 줌 (취향에 따라 제거 가능)
                        if (direction === 'up') {
                            // 위로 사라짐 (Intro 등)
                            el.style.transform = 'translateY(calc(-50% - 30px))';
                        } else {
                            // 아래로 대기 (나머지)
                            el.style.transform = 'translateY(calc(-50% + 30px))';
                        }
                    }
                };

                // 1. Intro ("My Approach") : ~ 12%까지 보임
                if (percent < 0.12) {
                    setVisible(0, true);
                } else {
                    setVisible(0, false, 'up'); // 위로 사라짐
                }

                // 2. Text 01 : 15% ~ 38%
                if (percent >= 0.15 && percent < 0.38) {
                    setVisible(1, true);
                } else {
                    setVisible(1, false, 'down'); // 아래에서 대기
                }

                // 3. Text 02 : 40% ~ 63%
                if (percent >= 0.40 && percent < 0.63) {
                    setVisible(2, true);
                } else {
                    setVisible(2, false, 'down');
                }

                // 4. Text 03 : 65% ~ 끝
                if (percent >= 0.65) {
                    setVisible(3, true);
                } else {
                    setVisible(3, false, 'down');
                }
            }

            window.addEventListener('scroll', () => {
                const scrollY = window.scrollY;
                const secTop = section.offsetTop;
                const secH = section.offsetHeight;
                const winH = window.innerHeight;

                let percent = (scrollY - secTop) / (secH - winH);
                
                if (percent > 0) {
                    targetDraw = 1; 
                } 
                else if (percent < 0) {
                    targetDraw = 0;
                }

                percent = Math.max(0, Math.min(1, percent));

                updateCards(percent);
                state = mapPercentToState(percent);

                if (state < 1.0) {
                    const wireOp = Math.max(0, 1.0 - state * 2.0); 
                    lineMat.opacity = wireOp;
                    dotMat.opacity = wireOp;
                    
                    solidMat.opacity = state;
                    allSets.forEach(s => s.mesh.visible = false);
                } else {
                    const subP = state - 1.0;
                    lineMat.opacity = 0; 
                    dotMat.opacity = 0;
                    solidMat.opacity = Math.max(0, 1.0 - subP * 5.0); 
                    allSets.forEach(s => s.mesh.visible = true);
                }
            });
            
            window.addEventListener('resize', () => {
                width = document.querySelector('.visual-col').clientWidth;
                height = window.innerHeight;
                renderer.setSize(width, height);
                const aspect = width / height;
                const frustumSize = 15.0; 
                camera.left = frustumSize * aspect / -2;
                camera.right = frustumSize * aspect / 2;
                camera.top = frustumSize / 2;
                camera.bottom = frustumSize / -2;
                camera.updateProjectionMatrix();
            });

        })();

        // [New] Image Marquee Population Logic & Drag Support
        (function(){
            const containerSection = document.getElementById('image-marquee-section');
            
            containerSection.innerHTML = `
                <div class="marquee-track-wrapper"><div class="marquee-track track-1" id="track-1"></div></div>
                <div class="marquee-track-wrapper"><div class="marquee-track track-2" id="track-2"></div></div>
                <div class="marquee-track-wrapper"><div class="marquee-track track-3" id="track-3"></div></div>
            `;

            const track1 = document.getElementById('track-1');
            const track2 = document.getElementById('track-2');
            const track3 = document.getElementById('track-3');

            function randomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            // [FIX] 화면 높이에 따라 이미지 배치를 유동적으로 조절하는 함수
            function createMarqueeItems(start, end, container) {
                // 현재 컨테이너 높이 계산 (노트북 등 작은 화면 대응)
                const sectionHeight = containerSection.clientHeight;
                
                for(let i=start; i<=end; i++) {
                    
                    // [구조 변경] Wrapper(위치) -> Item(디자인) -> Img
                    const wrapper = document.createElement('div');
                    wrapper.className = 'marquee-item-wrapper';

                    const div = document.createElement('div');
                    div.className = 'marquee-item';
                    
                    const h = randomInt(200, 320); 
                    wrapper.style.height = `${h}px`; // 높이는 래퍼에 지정

                    const mr = randomInt(300, 600);
                    wrapper.style.marginRight = `${mr}px`; // 간격도 래퍼에 지정

                    // [수정됨] 반응형 배치 로직
                    // 이미지가 섹션 밖으로 튀어나가지 않도록 최대 Y값을 계산
                    // sectionHeight - h(이미지 높이) - 50(여유 공간)
                    const maxTop = sectionHeight - h - 50; 
                    
                    // maxTop이 음수면(이미지가 너무 크면) 0으로 고정
                    const safeMaxTop = maxTop > 0 ? maxTop : 0;
                    
                    const mt = randomInt(0, safeMaxTop); 
                    
                    // 초기 위치 설정 (Wrapper가 담당)
                    wrapper.style.transform = `translateY(${mt}px)`;
                    
                    const img = document.createElement('img');
                    const imgNum = ((i - 1) % 36) + 1; 
                    img.src = `assets/info_image/${imgNum}.png`;
                    img.alt = `Work ${imgNum}`;
                    
                    img.onerror = function() {
                        this.style.display = 'none';
                        div.style.backgroundColor = '#d0d0d5';
                        const w = Math.floor(h * (randomInt(8, 14) / 10)); 
                        div.style.width = `${w}px`;
                        div.innerText = `File?\n${imgNum}.png`; 
                        div.style.color = '#fff';
                        div.style.fontSize = '0.8rem';
                        div.style.fontWeight = '400';
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                        div.style.textAlign = 'center';
                        div.style.lineHeight = '1.2';
                    };

                    div.appendChild(img);
                    wrapper.appendChild(div); // 래퍼 안에 아이템 넣기
                    container.appendChild(wrapper); // 컨테이너에 래퍼 넣기
                }
            }

            createMarqueeItems(1, 12, track1);
            createMarqueeItems(13, 24, track2);
            createMarqueeItems(25, 36, track3); 

            function cloneContent(track) {
                const items = Array.from(track.children);
                items.forEach(item => {
                    const clone = item.cloneNode(true);
                    clone.setAttribute('aria-hidden', 'true');
                    // 이벤트 리스너는 클론되지 않으므로 델리게이션(상위 요소 이벤트 위임) 방식 사용이 적합
                    track.appendChild(clone);
                });
            }

            cloneContent(track1);
            cloneContent(track2);
            cloneContent(track3);
            
            // ===============================================
            // [NEW] Z-INDEX HOVER LOGIC (수정됨)
            // ===============================================
            // 마우스가 올라간 요소만 앞으로 가져오고, 트랙 전체는 건드리지 않음
            containerSection.addEventListener('mouseover', (e) => {
                const wrapper = e.target.closest('.marquee-item-wrapper');
                if (wrapper) {
                    // 1. 해당 아이템을 트랙 내에서 맨 앞으로
                    wrapper.style.zIndex = 5000;
                }
            });

            containerSection.addEventListener('mouseout', (e) => {
                const wrapper = e.target.closest('.marquee-item-wrapper');
                if (wrapper) {
                    // 1. 아이템 z-index 초기화
                    wrapper.style.zIndex = '';
                }
            });

            // ===============================================
            // [DRAG & DROP LOGIC] (Updated for Wrapper)
            // ===============================================
            let isDragging = false;
            let dragItem = null; // 이것은 이제 wrapper가 됩니다.
            let startX = 0, startY = 0;
            let initialItemX = 0, initialItemY = 0;
            let startTrackX = 0; 
            let dragTrack = null;

            containerSection.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', onDrag);
            window.addEventListener('mouseup', endDrag);
            
            containerSection.addEventListener('touchstart', (e) => startDrag(e.touches[0]));
            window.addEventListener('touchmove', (e) => onDrag(e.touches[0]));
            window.addEventListener('touchend', endDrag);

            function getTranslateX(el) {
                const style = window.getComputedStyle(el);
                const matrix = new WebKitCSSMatrix(style.transform);
                return matrix.m41;
            }

            function startDrag(e) {
                const target = e.target || e; 
                // [수정] 래퍼를 찾습니다
                const item = target.closest('.marquee-item-wrapper');
                if (!item) return;

                isDragging = true;
                dragItem = item;
                dragTrack = item.closest('.marquee-track');
                item.classList.add('dragging');

                startX = e.clientX;
                startY = e.clientY;

                const style = window.getComputedStyle(item);
                const matrix = new WebKitCSSMatrix(style.transform);
                initialItemX = matrix.m41;
                initialItemY = matrix.m42;

                startTrackX = getTranslateX(dragTrack);
            }

            function onDrag(e) {
                if (!isDragging || !dragItem) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                const currentTrackX = getTranslateX(dragTrack);
                const trackDiff = currentTrackX - startTrackX; 

                let newX = initialItemX + dx - trackDiff;
                let newY = initialItemY + dy;

                const itemHeight = dragItem.offsetHeight; 
                const sectionHeight = containerSection.clientHeight; 

                const topLimit = 50; 
                if (newY < topLimit) {
                     newY = topLimit; 
                }
                
                const bottomLimit = sectionHeight - itemHeight - 50;
                if (newY > bottomLimit) {
                     newY = bottomLimit; 
                }

                dragItem.style.transform = `translate(${newX}px, ${newY}px)`;
                // scale은 CSS가 처리하도록 둡니다 (transform 속성을 분리할 수 없으므로 JS에선 translate만)
                // 단, dragging 클래스가 붙으면 CSS에서 scale(1.05)를 덮어씁니다.
            }

            function endDrag() {
                if (isDragging && dragItem) {
                    dragItem.classList.remove('dragging');
                }
                isDragging = false;
                dragItem = null;
                dragTrack = null;
            }

        })();

        // [New] Loading Logic
        (function() {
            // 스크롤 잠금
            document.body.style.overflow = 'hidden';

            const loader = document.getElementById('loading-screen');
            const percentEl = document.getElementById('loading-percent');
            const barEl = document.getElementById('loading-bar');
            
            // [NEW] 트랜지션 커튼 (검은 배경)
            const entryCurtain = document.getElementById('page-entry-curtain');

            let loadPercent = 0;
            
            const interval = setInterval(() => {
                if (loadPercent < 90) {
                    loadPercent += Math.floor(Math.random() * 5) + 1;
                    if(loadPercent > 90) loadPercent = 90;
                    
                    percentEl.innerText = loadPercent;
                    barEl.style.width = loadPercent + '%';
                }
            }, 100);

            // 로딩 완료
            function finishLoading() {
                clearInterval(interval);
                
                percentEl.innerText = 100;
                barEl.style.width = '100%';

                // [순서]
                // 1. 로딩 숫자/바 사라짐
                // 2. 검은 커튼이 아래로 내려가며 화면을 보여줌
                
                setTimeout(() => {
                    // 로딩 텍스트/바 숨김
                    loader.classList.add('hidden');
                    loader.style.display = 'none';

                    // 커튼 걷어내기 (위에서 덮고 있으므로 아래로 내림: top 0 -> 100%)
                    gsap.to(entryCurtain, {
                        top: "100%", 
                        duration: 0.8,
                        ease: "power3.inOut",
                        onComplete: () => {
                            entryCurtain.style.display = 'none';
                            document.body.style.overflow = ''; // 스크롤 잠금 해제
                        }
                    });

                }, 500);
            }

            window.addEventListener('load', finishLoading);
            setTimeout(finishLoading, 5000);
        })();
    </script>
</body>
</html>