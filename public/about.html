<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio - about Hanuk</title>
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/static/pretendard.css" />
    
    <style>
        :root {
            /* [Color Theme] Light Mode */
            --bg-color: #F5F5F7;
            --text-color: #1D1D1F;
            --accent-color: #2997ff; /* Blue */
            --sub-color-1: #9c6dff;  /* Purple */
            --sub-color-2: #4fd1c5;  /* Mint */
            --dim-color: #86868b;
            --text-sub: #6e6e73;
            --card-bg: #FFFFFF;
        }

        body, html {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Pretendard', sans-serif;
            width: 100%;
            cursor: default;
        }

        /* [Custom Cursor CSS] */
        .menu-item, .win-btn, #chat-minimized-icon, button, .send-btn, a, .skill-item, .bento-card, .circle-btn, .profile-card, .marquee-item { cursor: pointer; }

        #cursor-follower {
            position: fixed; top: 0; left: 0;
            width: 40px; height: 40px;
            
            /* [수정됨] 평상시 그라데이션 적용 & 테두리 제거 */
            border: none;
            background: linear-gradient(120deg, var(--accent-color), var(--sub-color-1), var(--sub-color-2), var(--accent-color));
            background-size: 300% 300%;
            animation: gradientCursor 4s ease infinite; /* 그라데이션이 흐르는 애니메이션 */
            
            /* [수정됨] 투명도 추가 (0.6 = 60% 불투명) */
            opacity: 0.6; 
            
            border-radius: 50%;
            pointer-events: none; z-index: 9999;
            margin-left: -20px; 
            margin-top: -20px;
            
            /* 트랜지션에 opacity 추가하여 호버 시 자연스럽게 전환 */
            transition: width 0.3s cubic-bezier(0.19, 1, 0.22, 1),
                        height 0.3s cubic-bezier(0.19, 1, 0.22, 1),
                        background-color 0.3s, margin 0.3s, mix-blend-mode 0.3s, opacity 0.3s;
                        
            display: flex; align-items: center; justify-content: center; overflow: hidden;
            
            /* 평상시엔 지정된 그라데이션 색상을 보여주기 위해 normal로 설정 */
            mix-blend-mode: normal; 
            will-change: transform; 
        }

        /* 그라데이션 애니메이션 키프레임 */
        @keyframes gradientCursor {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #cursor-text { 
            font-size: 12px; font-weight: 500; color: white; 
            opacity: 0; white-space: nowrap; 
            transition: opacity 0.2s; letter-spacing: 0.05em; 
        }

        #cursor-follower.active-enter {
            width: 80px; height: 80px;
            margin-left: -40px; margin-top: -40px; 
            
            /* [수정됨] 호버 시에는 흰색 배경 + 색상 반전(difference) 모드로 전환 */
            background: #ffffff;
            border-color: transparent; 
            mix-blend-mode: difference;
            
            /* [수정됨] 반전 효과 시에는 투명도를 100%로 하여 선명하게 반전되도록 함 */
            opacity: 1;
            
            /* 호버 시 그라데이션 애니메이션 멈춤 (단색 배경이므로) */
            animation: none;
        }

        .container {
            max-width: 1200px; margin: 0 auto; padding: 0 20px; box-sizing: border-box;
        }

        /* =========================================
           1. HERO SECTION
           ========================================= */
        #hero-section {
            position: relative; 
            width: 100%; 
            min-height: 100vh; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            background-color: var(--bg-color);
            overflow: hidden; 
            padding-bottom: 160px; 
            box-sizing: border-box;
        }

        .hero-layout-new {
            display: flex;
            flex-direction: column; 
            width: 100%;
            height: 100%;
            justify-content: center; 
            align-items: flex-start; 
            padding-left: 0;
            padding-top: 60px; 
        }

        .hero-text-block {
            text-align: left;
            color: var(--text-color);
            font-size: 3rem;
            line-height: 1.6;
            letter-spacing: -0.01em; 
            font-weight: 300; 
            word-break: keep-all;
            margin-bottom: 0px; 
            width: 100%; 
            z-index: 10; 
            position: relative;
        }

        .profile-card {
            width: 300px;
            height: 400px;
            perspective: 1000px;
            cursor: pointer;
            position: relative;
            transition: transform 0.3s ease;
            z-index: 20;
            align-self: flex-end; 
            margin-top: -55px; 
        }
        .profile-card:hover { transform: translate(2px, -4px); }

        .profile-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.5s ease-out;
            transform-style: preserve-3d;
            border-radius: 24px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
        }
        .profile-card:hover .profile-inner { box-shadow: 0 25px 50px rgba(0,0,0,0.1); }
        .profile-card.flipped .profile-inner { transform: rotateY(180deg); }

        .profile-front, .profile-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 24px;
            overflow: hidden;
            background-color: var(--card-bg);
        }

        .profile-front img { width: 100%; height: 100%; object-fit: cover; display: block; }
        .profile-back { transform: rotateY(180deg); background-color: #000; }
        .profile-video { width: 100%; height: 100%; object-fit: cover; display: block; pointer-events: none; }

        .scroll-indicator {
            position: relative; 
            width: 100%;
            text-align: center;
            font-size: 0.8rem; 
            opacity: 0.5; 
            animation: bounce 2s infinite; 
            z-index: 30;
            color: var(--text-color);
            margin-top: 0px; /* 사용자 조절 가능 */
            margin-bottom: 60px; 
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateY(0);}
            40% {transform: translateY(-10px);}
            60% {transform: translateY(-5px);}
        }

        @media (max-width: 1024px) {
            .hero-layout-new { align-items: center; }
            .hero-text-block { text-align: center; font-size: 2.5rem; margin-bottom: 40px; }
            .profile-card { align-self: center; margin-top: 0px; }
        }
        @media (max-width: 768px) {
            .hero-text-block { font-size: 1.8rem; }
            .profile-card { width: 280px; height: 373px; }
        }

        /* =========================================
           1.5. IMAGE MARQUEE SECTION
           ========================================= */
        #image-marquee-section {
            width: 100%;
            /* [수정됨] 높이를 줄임 (90vh -> 70vh, 800px -> 600px) */
            height: 70vh; 
            min-height: 600px; 
            background-color: var(--bg-color);
            position: relative; 
            overflow: hidden;
            padding: 100px 0; 
            box-sizing: border-box;
            touch-action: none; 
        }

        .marquee-track-wrapper {
            position: absolute; 
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; align-items: flex-start; 
            overflow: hidden;
            pointer-events: none; 
            /* 트랙 자체는 패딩의 영향을 받지 않고 전체를 쓰되, 내부 아이템 배치를 조절 */
            padding-top: 0; 
            transition: z-index 0.3s; /* 트랙 간 순서 변경 시 부드럽게 */
        }

        .marquee-track {
            display: flex; align-items: flex-start; 
            width: max-content;
            animation: marquee-scroll 60s linear infinite; 
            will-change: transform;
        }

        /* [수정됨] 속도 더 느리게 조정 (300s, 340s, 320s) */
        .track-1 { animation-duration: 300s; z-index: 1; }
        .track-2 { animation-duration: 340s; z-index: 2; margin-left: -15vw;} 
        .track-3 { animation-duration: 320s; z-index: 3; margin-left: -5vw;} 

        @keyframes marquee-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); } 
        }

        /* [NEW] 위치와 드래그를 담당하는 래퍼 */
        .marquee-item-wrapper {
            flex-shrink: 0;
            position: relative; /* z-index 적용을 위해 */
            pointer-events: auto;
            user-select: none;
            -webkit-user-drag: none;
            will-change: transform;
            transition: z-index 0.2s;
        }

        /* [MODIFIED] 디자인과 호버 효과를 담당하는 내부 아이템 */
        .marquee-item {
            width: 100%; height: 100%;
            border-radius: 24px;
            overflow: hidden;
            background-color: #e0e0e0; 
            position: relative;
            /* 호버 시 확대 효과 트랜지션 */
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s ease;
            transform-origin: center center;
        }
        
        .marquee-item img {
            width: auto; height: 100%;
            object-fit: cover; display: block;
            min-width: 100px; 
            pointer-events: none; 
        }

        /* [Hover Effect] 래퍼에 마우스를 올리면 내부 아이템이 커짐 */
        .marquee-item-wrapper:hover .marquee-item {
            transform: scale(1.15); /* 1.15배 확대 */
            box-shadow: 0 25px 50px rgba(0,0,0,0.25);
        }
        
        /* 드래그 중인 아이템 스타일 */
        .marquee-item-wrapper.dragging .marquee-item {
            cursor: grabbing;
            box-shadow: 0 30px 60px rgba(0,0,0,0.3);
            transform: scale(1.05); 
        }

        @media (max-width: 768px) {
            #image-marquee-section { height: 60vh; min-height: 500px; }
        }

        /* =========================================
           2. PHILOSOPHY SECTION
           ========================================= */
        #philosophy-section { 
            position: relative; 
            width: 100%; 
            height: 600vh; 
            background-color: var(--bg-color);
        }
        
        .philo-container { 
            position: sticky; 
            top: 0;
            width: 100%; 
            max-width: 1200px; 
            margin: 0 auto;
            height: 100vh; 
            display: flex;
            overflow: hidden; 
        }

        .text-col { 
            width: 35%; 
            margin-left: 15%; 
            padding-right: 50px; 
            box-sizing: border-box; 
            z-index: 10; 
            position: relative; 
            display: flex;
            align-items: center; 
        }

        .text-block {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            transform: translateY(-50%);
            background-color: transparent; 
            padding: 0; 
            opacity: 0; 
            pointer-events: none; 
        }

        .philo-intro-title {
            /* [수정됨] 크기 5rem -> 4rem으로 축소 */
            font-size: 4rem; 
            font-weight: 300; 
            line-height: 1;   
            
            color: var(--text-color); margin-bottom: 20px;
            letter-spacing: -0.02em;
        }
        .philo-intro-sub {
            font-size: 2rem; color: var(--accent-color);
            font-weight: 300;
        }
        
        .philo-label {
            color: var(--accent-color); font-size: 3.0rem; font-weight: 600;
            text-transform: uppercase; letter-spacing: 2px; margin-bottom: 0px; display: block;
        }
        .philo-desc { font-size: 1.5rem; line-height: 1.5; font-weight: 400; word-break: keep-all; color: var(--text-color); margin-top: 12px; }

        .visual-col {
            width: 50%; 
            height: 100vh; 
            display: flex; align-items: center; justify-content: center;
        }
        #three-canvas { width: 100%; height: 100%; outline: none; }

        /* =========================================
           3. KEY DETAIL SECTION
           ========================================= */
        #key-detail-section {
            padding: 100px 0 200px 0;
            background-color: var(--bg-color);
            position: relative;
            z-index: 10;
        }

        .key-detail-title {
            font-size: 5rem; 
            font-weight: 300; 
            margin-bottom: 60px;
            color: var(--text-color); 
            line-height: 1; 
            text-align: left; 
        }

        .bento-grid {
            display: grid; grid-template-columns: repeat(4, 290px);
            gap: 10px; justify-content: center; align-items: start;
        }

        .col-stack { display: flex; flex-direction: column; gap: 10px; }

        .bento-card {
            background-color: transparent; perspective: 1000px; width: 290px;
            position: relative; transition: transform 0.3s ease; cursor: pointer;
        }
        .bento-card:hover { transform: translateY(-5px); }
        .bento-card.card-language { cursor: default; }
        .bento-card.card-language:hover { transform: none; }

        .card-inner {
            position: relative; width: 100%; height: 100%; text-align: left;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-style: preserve-3d; border-radius: 24px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.02);
        }
        .bento-card:hover .card-inner { box-shadow: 0 10px 30px rgba(0,0,0,0.05); }
        .bento-card.flipped .card-inner { transform: rotateY(180deg); }

        .card-front, .card-back {
            position: absolute; width: 100%; height: 100%;
            -webkit-backface-visibility: hidden; backface-visibility: hidden;
            background-color: var(--card-bg); border-radius: 24px;
            padding: 30px; box-sizing: border-box; display: flex; flex-direction: column;
        }
        .card-back { transform: rotateY(180deg); overflow: hidden; }

        .card-title { font-size: 2rem; font-weight: 600; margin: 0 0 30px 0; color: var(--text-color); letter-spacing: -0.02em; }
        .sub-card-title { font-size: 1.5rem; font-weight: 600; margin: 0 0 20px 0; color: var(--text-color); }
        .item-main-text { font-size: 1rem; font-weight: 600; color: var(--text-color); margin-bottom: 12px; }
        .item-sub-text { font-size: 12px; font-weight: 400; color: var(--text-sub); margin-bottom: 0px; line-height: 1.2; }
        .date-text { font-size: 12px; font-weight: 400; color: var(--text-color); margin-top: 10px; display: block; }

        .f-600-12 { font-weight: 600; font-size: 12px; color: var(--text-color); }
        .f-400-12 { font-weight: 400; font-size: 12px; color: var(--text-sub); }
        .f-600-10 { font-weight: 600; font-size: 10px; color: var(--text-color); }
        .f-400-10 { font-weight: 400; font-size: 10px; color: var(--text-sub); }
        .mb-4 { margin-bottom: 4px; }
        .mb-8 { margin-bottom: 8px; }

        .card-education { height: 360px; }
        .edu-content { margin-top: auto; }
        .edu-back-list { display: flex; flex-direction: column; gap: 15px; height: 100%; }
        .edu-section-title { font-weight: 600; font-size: 12px; color: var(--accent-color); margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #eee; }
        .edu-row { display: flex; gap: 10px; align-items: flex-start; }
        .edu-year-col { width: 30px; flex-shrink: 0; display: flex; flex-direction: column; gap: 4px; }
        .edu-desc-col { flex: 1; display: flex; flex-direction: column; gap: 4px; }

        .card-language { height: 100px; }
        .lang-list { display: flex; flex-direction: column; gap: 2px; }
        .lang-item { display: flex; justify-content: flex-start; align-items: center; gap: 8px; }
        .lang-name { font-size: 12px; font-weight: 600; }
        .lang-level { font-size: 12px; font-weight: 400; color: var(--text-sub); }

        .card-experience { height: 250px; }
        .exp-content { margin-top: auto; }
        .exp-back-content { display: flex; flex-direction: column; gap: 16px; margin-top: auto; }
        .exp-block { display: flex; flex-direction: column; gap: 2px; }

        .card-capabilities { height: 360px; }
        .capa-list { display: flex; flex-direction: column; gap: 5px; margin-top: auto; align-items: flex-start; }
        .capa-row { display: flex; gap: 5px; }
        .capa-tag { font-size: 1rem; font-weight: 400; color: var(--text-color); border: 1px solid var(--text-color); padding: 6px 10px; border-radius: 999px; transition: all 0.2s; }
        .capa-tag:hover { border-color: var(--accent-color); color: var(--accent-color); }
        .tools-vertical-list { display: flex; flex-direction: column; gap: 16px; margin-top: auto; }
        .tool-row-v { display: flex; flex-direction: column; gap: 4px; }
        .tool-cat-v { font-size: 12px; font-weight: 600; color: var(--text-color); }
        .tool-items-v { font-size: 12px; font-weight: 400; color: var(--text-sub); line-height: 1.3; }

        .card-connect { height: 200px; }
        .connect-front-list { display: flex; flex-direction: column; gap: 4px; margin-top: auto; }
        .contact-back-content { display: flex; flex-direction: column; gap: 16px; margin-top: auto; }
        .contact-block { display: flex; flex-direction: column; gap: 2px; }
        .contact-link { text-decoration: none; color: var(--accent-color); transition: opacity 0.2s; }
        .contact-link:hover { opacity: 0.7; }

        .circle-wrapper { width: 290px; height: 150px; display: flex; justify-content: flex-end; }
        .circle-btn { width: 150px; height: 150px; border-radius: 50%; background-color: var(--card-bg); display: flex; align-items: center; justify-content: center; flex-direction: column; transition: all 0.3s; border: 1px solid transparent; text-decoration: none; box-shadow: 0 4px 20px rgba(0,0,0,0.02); }
        .circle-btn:hover { transform: scale(1.05); border-color: var(--accent-color); box-shadow: 0 10px 20px rgba(41, 151, 255, 0.15); }
        .circle-arrow { width: 75px; height: 75px; margin-top: 5px; -webkit-mask: url('assets/Go_2.svg') no-repeat center / contain; mask: url('assets/Go_2.svg') no-repeat center / contain; background-color: var(--text-color); transition: transform 0.3s ease, background-color 0.3s ease; }
        .circle-btn:hover .circle-arrow { transform: translate(3px, -3px); background-color: var(--accent-color); }

        .footer { text-align: center; padding: 50px 20px; border-top: 1px solid #eee; background-color: #fff; margin-top: 100px; }
        .contact-simple { font-size: 0.9rem; color: var(--dim-color); }
    </style>
</head>
<body>

    <div id="cursor-follower">
        <span id="cursor-text"></span>
    </div>

    <!-- HERO SECTION -->
    <section id="hero-section">
        <div class="container hero-layout-new">
            <div class="hero-text-block">
                안녕하세요,<br>
                사람과 기술. 사용자와 서비스.<br>
                그 사이를 잇고, 밀도높은 경험을 만드는<br>
                UX·인터랙션 디자이너 이한욱입니다.
            </div>
            <!-- Profile Card -->
            <div class="profile-card" onclick="toggleProfile(this)">
                <div class="profile-inner">
                    <div class="profile-front">
                        <img src="assets/Profile_Photo.png" alt="Hanuk Profile" onerror="this.style.display='none'; this.parentNode.style.backgroundColor='#e0e0e0'">
                    </div>
                    <div class="profile-back">
                        <video class="profile-video" autoplay loop muted playsinline>
                            <source src="assets/Profile_Video.mp4" type="video/mp4">
                        </video>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- NEW: IMAGE MARQUEE SECTION -->
    <section id="image-marquee-section">
        <!-- JS가 트랙을 생성합니다 -->
    </section>

    <div class="scroll-indicator">SCROLL DOWN</div>

    <!-- PHILOSOPHY SECTION -->
    <section id="philosophy-section">
        <div class="philo-container">
            <div class="text-col">
                <!-- [수정됨] 타이틀 텍스트 변경: How I Work -> My Approach -->
                <div class="text-block" id="philo-text-intro">
                    <h2 class="philo-intro-title">My Approach</h2>
                    
                </div>
                
                <div class="text-block" id="philo-text-1">
                    <span class="philo-label">01.</span>
                    <p class="philo-desc">
                        일상과 데이터 이면의 진짜 니즈를<br>
                        파악하여 문제를 정의합니다. <br>
                        심미성 이전에 <strong>논리적 타당성</strong>을<br>
                        먼저 고민합니다.
                    </p>
                </div>
                <div class="text-block" id="philo-text-2">
                    <span class="philo-label">02.</span>
                    <p class="philo-desc">
                        이를 바탕으로 도출한<br>
                        인사이트와 아이디어를<br>
                        감각적이고 <strong>완성도 높은 비주얼</strong>로<br>
                        표현해냅니다.
                    </p>
                </div>
                <div class="text-block" id="philo-text-3">
                    <span class="philo-label">03.</span>
                    <p class="philo-desc">
                        정적인 화면에 머무르지 않고,<br>
                        <strong>입체적인 인터랙션</strong>으로 구현하여<br>
                        즐거운 경험으로 완성합니다.
                    </p>
                </div>
            </div>
            <div class="visual-col">
                <canvas id="three-canvas"></canvas>
            </div>
        </div>
    </section>

    <!-- KEY DETAIL SECTION -->
    <section id="key-detail-section" >
        <div class="container">
            <h2 class="key-detail-title">Key Info</h2>
            <div class="bento-grid">
                <!-- COL 1 -->
                <div class="bento-card card-education" onclick="toggleFlip(this)">
                    <div class="card-inner">
                        <div class="card-front" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                            <h3 class="card-title">Education</h3>
                            <div class="edu-content">
                                <div class="item-main-text">Hongik University</div>
                                <div class="item-sub-text">Industrial Design Major</div>
                                <div class="item-sub-text">Product & Interaction</div>
                                <span class="date-text">2017.03 - 2023.02</span>
                            </div>
                        </div>
                        <div class="card-back" style="padding: 20px;">
                            <div class="edu-back-list">
                                <div>
                                    <div class="edu-section-title">Exhibitions & Research</div>
                                    <div class="edu-row">
                                        <div class="edu-year-col">
                                            <div class="f-600-10">2024</div>
                                            <div class="f-600-10">2024</div>
                                            <div class="f-600-10">2024</div>
                                        </div>
                                        <div class="edu-desc-col">
                                            <div class="f-400-10">Hongik Industrial Design Degree Show</div>
                                            <div class="f-400-10">AutomotiveUI’24 International Conference</div>
                                            <div class="f-400-10">Zurich Design Week 2024</div>
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <div class="edu-section-title">Industry Collaborations</div>
                                    <div class="edu-row">
                                        <div class="edu-year-col">
                                            <div class="f-600-10">2023</div>
                                            <div class="f-600-10" style="margin-top:12px">2023</div>
                                            <div class="f-600-10" style="margin-top:12px">2023</div>
                                        </div>
                                        <div class="edu-desc-col">
                                            <div>
                                                <div class="f-600-10">Hyundai Motor Group</div>
                                                <div class="f-400-10">Future Mobility UX & Air Conditioning System</div>
                                            </div>
                                            <div>
                                                <div class="f-600-10">University of Zurich (Veterinary Dept.)</div>
                                                <div class="f-400-10">Product for Small Animal</div>
                                            </div>
                                            <div>
                                                <div class="f-600-10">Kolon Glotech</div>
                                                <div class="f-400-10">Autonomous Mobility Lifestyle & CMF</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <div class="edu-section-title">Honors & Activities</div>
                                    <div class="edu-row">
                                        <div class="edu-year-col">
                                            <div class="f-600-10">2024</div>
                                            <div class="f-600-10" style="margin-top:12px">2022<br>-24</div>
                                            <div class="f-600-10" style="margin-top:12px">2022<br>-24</div>
                                        </div>
                                        <div class="edu-desc-col">
                                            <div>
                                                <div class="f-600-10">Patent Application</div>
                                                <div class="f-400-10">Vehicle Air Conditioning & Control System</div>
                                            </div>
                                            <div>
                                                <div class="f-600-10">Industrial Design Student Council</div>
                                                <div class="f-400-10">Head of Graphic Design ('24)</div>
                                            </div>
                                            <div>
                                                <div class="f-600-10">Hongik Central Library</div>
                                                <div class="f-400-10">Institutional Branding & Promotional Visuals</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- COL 2 -->
                <div class="col-stack">
                    <div class="bento-card card-language">
                        <div class="card-inner">
                            <div class="card-front" style="padding-top: 15px; padding-left:20px; padding-bottom:0px; justify-content:center;">
                                <h4 class="sub-card-title" style="margin-bottom: 0; margin-right: 20px;">Language</h4>
                                <div class="lang-list" style="flex:1; justify-content:center;">
                                    <div class="lang-item">
                                        <span class="lang-name">Korean</span>
                                        <span class="lang-level">Native</span>
                                    </div>
                                    <div class="lang-item">
                                        <span class="lang-name">English</span>
                                        <span class="lang-level">Fluent</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="bento-card card-experience" onclick="toggleFlip(this)">
                        <div class="card-inner">
                            <div class="card-front" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                                <h3 class="card-title">Experience</h3>
                                <div class="exp-content">
                                    <div class="item-main-text">Cheil Worldwide</div>
                                    <div class="item-sub-text">Global Samsung Retail Store</div>
                                    <div class="item-sub-text">Device Experience App Content Planning</div>
                                    <div class="item-sub-text">Freelance</div>
                                    <span class="date-text">2025.02 - Present</span>
                                </div>
                            </div>
                            <div class="card-back" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                                <h3 class="card-title">Experience</h3>
                                <div class="exp-back-content">
                                    <div class="exp-block">
                                        <div class="f-600-12">1H 2025</div>
                                        <div class="f-400-12">SmartThings: Galaxy Connected Experience</div>
                                        <div class="f-400-10" style="margin-top:2px;">Designed multi-device UX flows and visual strategies to showcase Galaxy ecosystem connectivity.</div>
                                    </div>
                                    <div class="exp-block">
                                        <div class="f-600-12">2H 2025</div>
                                        <div class="f-400-12">Samsung Mobile Flagship Device Experience</div>
                                        <div class="f-400-10" style="margin-top:2px;">Planned in-app media scenarios and interactive demo content to maximize feature delivery.</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- COL 3 -->
                <div class="bento-card card-capabilities" onclick="toggleFlip(this)">
                    <div class="card-inner">
                        <div class="card-front" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                            <h3 class="card-title">Capabilities</h3>
                            <div class="capa-list">
                                <div class="capa-row">
                                    <div class="capa-tag">UX/UI</div>
                                    <div class="capa-tag">Interaction</div>
                                </div>
                                <div class="capa-row">
                                     <div class="capa-tag">3D</div>
                                     <div class="capa-tag">XR</div>
                                     <div class="capa-tag">Prototyping</div>
                                </div>
                                <div class="capa-row">
                                    <div class="capa-tag">Interactive Web</div>
                                </div>
                            </div>
                        </div>
                        <div class="card-back" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                            <h4 class="sub-card-title">Tools</h4>
                            <div class="tools-vertical-list">
                                <div class="tool-row-v">
                                    <span class="tool-cat-v">3D</span>
                                    <span class="tool-items-v">Blender, Rhino</span>
                                </div>
                                <div class="tool-row-v">
                                    <span class="tool-cat-v">Rendering</span>
                                    <span class="tool-items-v">KeyShot</span>
                                </div>
                                <div class="tool-row-v">
                                    <span class="tool-cat-v">UX/UI & Prototyping</span>
                                    <span class="tool-items-v">Figma, Framer, Unity</span>
                                </div>
                                <div class="tool-row-v">
                                    <span class="tool-cat-v">Adobe</span>
                                    <span class="tool-items-v">Photoshop, Illustrator, Premiere Pro</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- COL 4 -->
                <div class="col-stack">
                    <div class="bento-card card-connect" onclick="toggleFlip(this)">
                        <div class="card-inner">
                            <div class="card-front" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                                <h4 class="sub-card-title">Connect</h4>
                                <div class="connect-front-list">
                                    <div class="f-600-12">Based in</div>
                                    <div class="f-400-12 mb-8">Seoul(KST)</div>
                                    <div class="f-600-12">Flexible</div>
                                    <div class="f-400-12">Happy to discuss the right setup.</div>
                                </div>
                            </div>
                            <div class="card-back" style="padding-top: 15px; padding-left:20px; padding-bottom:20px">
                                <h4 class="sub-card-title">Contact</h4>
                                <div class="contact-back-content">
                                    <div class="contact-block">
                                        <div class="f-600-12">E-mail</div>
                                        <div class="f-400-12">hnkl1520@gmail.com</div>
                                    </div>
                                    <div class="contact-block">
                                        <div class="f-600-12">Linkedin</div>
                                        <a href="https://www.google.com" target="_blank" class="f-400-12 contact-link">linkedin.com/in/hanuk</a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="circle-wrapper">
                        <a href="works.html" class="circle-btn">
                            <div class="circle-arrow"></div>
                        </a>
                    </div>
                </div>

            </div>
        </div>
    </section>

    <footer class="footer">
        <p class="contact-simple">© 2026 Hanwook Lee. All rights reserved.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Profile Flip
        function toggleProfile(card) {
            if (card.classList.contains('flipped')) {
                card.classList.remove('flipped');
            } else {
                card.classList.add('flipped');
            }
        }

        // Bento Grid Flip
        function toggleFlip(card) {
            if (card.classList.contains('flipped')) {
                card.classList.remove('flipped');
                if (card.flipTimeout) {
                    clearTimeout(card.flipTimeout);
                    card.flipTimeout = null;
                }
            } else {
                card.classList.add('flipped');
                card.flipTimeout = setTimeout(() => {
                    if (card.classList.contains('flipped')) {
                        card.classList.remove('flipped');
                    }
                }, 5000);
            }
        }

        // Custom Jelly Cursor Logic
        (function() {
            const cursor = document.getElementById('cursor-follower');
            let mouseX = window.innerWidth / 2;
            let mouseY = window.innerHeight / 2;
            let cursorX = mouseX;
            let cursorY = mouseY;
            let velX = 0;
            let velY = 0;
            let scaleX = 1;
            let scaleY = 1;

            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            function animateCursor() {
                // [속도 조절] 0.15 -> 0.1로 변경
                // 이 값이 작을수록(0.05 ~ 0.1) 커서가 더 느리고 부드럽게(쫀득하게) 따라옵니다.
                // 이 값이 클수록(0.2 ~ 0.3) 커서가 빠릿하게 붙습니다.
                const ease = 0.1; 
                
                const nextX = cursorX + (mouseX - cursorX) * ease;
                const nextY = cursorY + (mouseY - cursorY) * ease;
                
                velX = nextX - cursorX;
                velY = nextY - cursorY;
                cursorX = nextX;
                cursorY = nextY;
                
                const dist = Math.sqrt(velX * velX + velY * velY);
                const angle = Math.atan2(velY, velX);
                
                // [쫀득함 조절] 0.05 -> 0.1로 변경
                // 움직일 때 원이 찌그러지는 정도입니다. 값이 클수록 더 많이 늘어납니다.
                const stretch = Math.min(dist * 0.1, 0.5); 
                
                scaleX = 1 + stretch;      
                scaleY = 1 - stretch * 0.4; 
                
                cursor.style.transform = `translate3d(${cursorX}px, ${cursorY}px, 0) rotate(${angle}rad) scale(${scaleX}, ${scaleY})`;
                requestAnimationFrame(animateCursor);
            }
            animateCursor();

            // [수정됨] 이벤트 위임(Delegation) 방식으로 변경
            // 동적으로 생성되는 marquee-item-wrapper도 감지하기 위해 document 전체에서 이벤트를 잡습니다.
            document.addEventListener('mouseover', (e) => {
                // 커서가 커져야 할 요소들 정의
                const target = e.target.closest('a, button, .skill-item, .contact-btn, .bento-card, .circle-btn, .profile-card, .marquee-item, .marquee-item-wrapper');
                if (target) {
                    cursor.classList.add('active-enter');
                } else {
                    cursor.classList.remove('active-enter');
                }
            });
            
            // 기존 정적 바인딩 코드는 제거하거나 위 로직으로 대체됨
        })();

        // 3D Logic + Scroll
        (function() {
            const canvas = document.querySelector('#three-canvas');
            const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            
            let width = document.querySelector('.visual-col').clientWidth;
            let height = window.innerHeight;
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);

            const scene = new THREE.Scene();
            
            const aspect = width / height;
            const frustumSize = 15.0; 
            const camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2,
                frustumSize * aspect / 2,
                frustumSize / 2,
                frustumSize / -2,
                0.1,
                100
            );
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const point = new THREE.PointLight(0x2997ff, 0.8);
            point.position.set(5, 5, 5);
            scene.add(point);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(-5, 5, 2);
            scene.add(dirLight);

            const group = new THREE.Group();
            scene.add(group);

            // [MODIFIED] 1. POINTS & LINES (Animated Drawing)
            const TOTAL_SIZE = 2.2;
            const boxGeo = new THREE.BoxGeometry(TOTAL_SIZE, TOTAL_SIZE, TOTAL_SIZE);
            
            // 1-1. Dot Cube (Vertices)
            const dotGeo = new THREE.BufferGeometry();
            const vertices = [];
            const posAttr = boxGeo.attributes.position;
            for(let i=0; i<posAttr.count; i++){
                vertices.push(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i));
            }
            dotGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const dotMat = new THREE.PointsMaterial({ color: 0x2997ff, size: 0.15 });
            const dotCube = new THREE.Points(dotGeo, dotMat);
            group.add(dotCube);

            // 1-2. Line Cube (Animated Edges)
            const edgesGeo = new THREE.EdgesGeometry(boxGeo);
            const lineMat = new THREE.LineDashedMaterial({ 
                color: 0x2997ff, 
                dashSize: 0, 
                gapSize: 1000, 
                transparent: true, 
                opacity: 0.9 
            });
            const lineCube = new THREE.LineSegments(edgesGeo, lineMat);
            lineCube.computeLineDistances();
            group.add(lineCube);

            // 1-3. Solid Cube (Existing)
            const solidMat = new THREE.MeshPhysicalMaterial({
                color: 0x2997ff, metalness: 0.0, roughness: 1.0, 
                transparent: true, opacity: 0 
            });
            const solidCube = new THREE.Mesh(boxGeo, solidMat);
            group.add(solidCube);

            // 2. CLONER SETS (Explosion)
            const unitGeo = new THREE.BoxGeometry(1, 1, 1);
            const clonerMat = new THREE.MeshPhysicalMaterial({
                color: 0xe0e0e0, metalness: 0.0, roughness: 1.0
            });

            function createSet(gridCnt, colorOrType, baseScale, targetScale, layoutType='standard') {
                const count = gridCnt ** 3;
                const mesh = new THREE.InstancedMesh(unitGeo, clonerMat, count);
                const data = [];
                const dummy = new THREE.Object3D();
                const unitSize = TOTAL_SIZE / gridCnt;
                const gap = unitSize * 1.05; 
                const purpleColor = new THREE.Color(0x9c6dff);
                const mintColor = new THREE.Color(0x4fd1c5);
                const baseColor = new THREE.Color(0xe0e0e0);
                const maxDist = Math.sqrt(3 * Math.pow((gridCnt-1)/2, 2));

                let idx = 0;
                for(let x=0; x<gridCnt; x++){
                    for(let y=0; y<gridCnt; y++){
                        for(let z=0; z<gridCnt; z++){
                            let ix = x - (gridCnt-1)/2;
                            let iy = y - (gridCnt-1)/2;
                            let iz = z - (gridCnt-1)/2;
                            let pos = new THREE.Vector3(ix, iy, iz);
                            if (layoutType === 'rotated') pos.set(-iy, ix, iz); 
                            else if (layoutType === 'standard') pos.addScalar(0.2); 
                            
                            data.push({
                                ix: pos.x, iy: pos.y, iz: pos.z, 
                                gap,        
                                visualBase: baseScale.clone().multiplyScalar(0.9), 
                                visualTarget: targetScale.clone().multiplyScalar(0.9),
                                unitSize,
                                randPhase: Math.random() * 100
                            });

                            dummy.position.set(0,0,0);
                            dummy.scale.set(0,0,0);
                            dummy.updateMatrix();
                            mesh.setMatrixAt(idx, dummy.matrix);
                            
                            const dist = Math.sqrt(ix*ix + iy*iy + iz*iz);
                            const alpha = Math.min(1, dist / maxDist);

                            if (colorOrType === 'purple_gradient') {
                                const t = alpha * alpha; 
                                const c = baseColor.clone().lerp(purpleColor, t);
                                mesh.setColorAt(idx, c);
                            } else if (colorOrType === 'mint_gradient') {
                                const c = mintColor.clone().lerp(baseColor, alpha);
                                mesh.setColorAt(idx, c);
                            } else {
                                mesh.setColorAt(idx, colorOrType);
                            }
                            idx++;
                        }
                    }
                }
                group.add(mesh);
                return { mesh, data, count };
            }

            const set1 = createSet(5, 'purple_gradient', new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.4, 0.6, 0.04), 'rotated');
            const set2 = createSet(5, new THREE.Color(0x2997ff), new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.6, 0.6, 0.6), 'rotated');
            const set3 = createSet(4, 'mint_gradient', new THREE.Vector3(0.0, 0.0, 0.0), new THREE.Vector3(0.15, 1.1, 0.15), 'offset');
            const allSets = [set1, set2, set3];
            allSets.forEach(s => s.mesh.visible = false);

            const clock = new THREE.Clock();
            let state = 0; 
            
            let currentDraw = 0; 
            let targetDraw = 0;  
            
            let tempScale = new THREE.Vector3();
            const dummy = new THREE.Object3D();

            function animate() {
                requestAnimationFrame(animate);
                const time = clock.getElapsedTime() * 0.5;

                // Rotation
                if (state < 0.9) group.rotation.y += 0.005; 
                else group.rotation.y += (Math.PI / 2 - group.rotation.y) * 0.05;

                // [UPDATE] Auto Line Drawing Logic
                currentDraw += (targetDraw - currentDraw) * 0.005;
                
                const maxDash = 100; 
                lineCube.material.dashSize = currentDraw * maxDash;
                
                // 3D Logic (Explosion)
                if(state > 0.9) {
                    const p = Math.max(0, state - 1.0); 
                    const spreadProgress = Math.min(p * 2.0, 1.0); 
                    const spread = 1.0 + (spreadProgress * 0.4);

                    allSets.forEach((set, sIdx) => {
                        let i = 0;
                        for(let data of set.data) {
                            dummy.position.set(
                                data.ix * data.gap * spread,
                                data.iy * data.gap * spread,
                                data.iz * data.gap * spread
                            );
                            const diag = data.ix + data.iy + data.iz; 
                            const val = time * 2.5 - diag - (sIdx * 2.5);
                            let scaleFactor = Math.pow((Math.sin(val) + 1) / 2, 1.5);
                            let animatedScale = new THREE.Vector3().lerpVectors(data.visualBase, data.visualTarget, scaleFactor);
                            const morphProgress = Math.min(p * 1.5, 1.0);
                            const solidLookScale = new THREE.Vector3(data.unitSize, data.unitSize, data.unitSize);
                            tempScale.lerpVectors(solidLookScale, animatedScale, morphProgress);
                            
                            dummy.scale.copy(tempScale);
                            dummy.updateMatrix();
                            set.mesh.setMatrixAt(i, dummy.matrix);
                            i++;
                        }
                        set.mesh.instanceMatrix.needsUpdate = true;
                    });
                } else {
                    if (set1.mesh.visible) {
                        allSets.forEach(set => {
                            let i = 0;
                            for(let data of set.data) {
                                dummy.position.set(data.ix*data.gap, data.iy*data.gap, data.iz*data.gap);
                                dummy.scale.set(data.unitSize, data.unitSize, data.unitSize); 
                                dummy.updateMatrix();
                                set.mesh.setMatrixAt(i, dummy.matrix);
                                i++;
                            }
                            set.mesh.instanceMatrix.needsUpdate = true;
                        });
                    }
                }
                renderer.render(scene, camera);
            }
            animate();

            // SCROLL SYNC
            const section = document.getElementById('philosophy-section');
            const texts = [
                document.getElementById('philo-text-intro'),
                document.getElementById('philo-text-1'),
                document.getElementById('philo-text-2'),
                document.getElementById('philo-text-3')
            ];

            function mapPercentToState(p) {
                // [수정됨] 타이밍 조절
                // 기존: 0.55까지 와이어프레임 유지 -> 02 텍스트(0.40 등장)와 불일치
                // 변경: 0.40부터 솔리드화 시작하여 텍스트 등장과 싱크를 맞춤
                
                // Phase 1: Wireframe (Intro ~ 01 구간)
                if (p <= 0.40) {
                    return 0; 
                }
                // Phase 2: Solidify (02 구간: 0.40 ~ 0.60)
                // 0.40에서 시작해 0.60이 되면 완전히 솔리드 큐브가 됨
                else if (p <= 0.60) {
                    return (p - 0.40) / 0.2; 
                }
                // Phase 3: Explode (03 구간: 0.60 이후)
                // 0.60부터 폭발 시작
                else {
                    return 1.0 + ((p - 0.60) / 0.40);
                }
            }

            function updateCards(percent) {
                // [수정됨] 스크롤 간격 단축 로직 적용
                
                // Text 0 (Intro)
                let op0 = 0, tr0 = 0;
                if (percent < 0.10) {
                    op0 = 1;
                } else if (percent < 0.15) {
                    op0 = 1 - (percent - 0.10) * 20; 
                    tr0 = (percent - 0.10) * -50;
                }

                // Text 1 ("01")
                let op1 = 0, tr1 = 50;
                if (percent >= 0.15 && percent < 0.20) {
                    op1 = (percent - 0.15) * 20;
                    tr1 = 50 - (op1 * 50);
                } else if (percent >= 0.20 && percent < 0.35) {
                    op1 = 1; tr1 = 0;
                } else if (percent >= 0.35 && percent < 0.40) {
                    op1 = 1 - (percent - 0.35) * 20;
                    tr1 = (percent - 0.35) * -50;
                }

                // Text 2 ("02")
                let op2 = 0, tr2 = 50;
                if (percent >= 0.40 && percent < 0.45) {
                    op2 = (percent - 0.40) * 20;
                    tr2 = 50 - (op2 * 50);
                } else if (percent >= 0.45 && percent < 0.60) {
                    op2 = 1; tr2 = 0;
                } else if (percent >= 0.60 && percent < 0.65) {
                    op2 = 1 - (percent - 0.60) * 20;
                    tr2 = (percent - 0.60) * -50;
                }

                // Text 3 ("03")
                let op3 = 0, tr3 = 50;
                if (percent >= 0.65 && percent < 0.70) {
                    op3 = (percent - 0.65) * 20;
                    tr3 = 50 - (op3 * 50);
                } else if (percent >= 0.70) {
                    op3 = 1; tr3 = 0;
                }

                texts[0].style.opacity = op0;
                texts[0].style.transform = `translateY(calc(-50% + ${tr0}px))`;
                
                texts[1].style.opacity = op1;
                texts[1].style.transform = `translateY(calc(-50% + ${tr1}px))`;

                texts[2].style.opacity = op2;
                texts[2].style.transform = `translateY(calc(-50% + ${tr2}px))`;

                texts[3].style.opacity = op3;
                texts[3].style.transform = `translateY(calc(-50% + ${tr3}px))`;
            }

            window.addEventListener('scroll', () => {
                const scrollY = window.scrollY;
                const secTop = section.offsetTop;
                const secH = section.offsetHeight;
                const winH = window.innerHeight;

                let percent = (scrollY - secTop) / (secH - winH);
                
                if (percent > 0) {
                    targetDraw = 1; 
                } 
                else if (percent < 0) {
                    targetDraw = 0;
                }

                percent = Math.max(0, Math.min(1, percent));

                updateCards(percent);
                state = mapPercentToState(percent);

                if (state < 1.0) {
                    const wireOp = Math.max(0, 1.0 - state * 2.0); 
                    lineMat.opacity = wireOp;
                    dotMat.opacity = wireOp;
                    
                    solidMat.opacity = state;
                    allSets.forEach(s => s.mesh.visible = false);
                } else {
                    const subP = state - 1.0;
                    lineMat.opacity = 0; 
                    dotMat.opacity = 0;
                    solidMat.opacity = Math.max(0, 1.0 - subP * 5.0); 
                    allSets.forEach(s => s.mesh.visible = true);
                }
            });
            
            window.addEventListener('resize', () => {
                width = document.querySelector('.visual-col').clientWidth;
                height = window.innerHeight;
                renderer.setSize(width, height);
                const aspect = width / height;
                const frustumSize = 15.0; 
                camera.left = frustumSize * aspect / -2;
                camera.right = frustumSize * aspect / 2;
                camera.top = frustumSize / 2;
                camera.bottom = frustumSize / -2;
                camera.updateProjectionMatrix();
            });

        })();

        // [New] Image Marquee Population Logic & Drag Support
        (function(){
            const containerSection = document.getElementById('image-marquee-section');
            
            containerSection.innerHTML = `
                <div class="marquee-track-wrapper"><div class="marquee-track track-1" id="track-1"></div></div>
                <div class="marquee-track-wrapper"><div class="marquee-track track-2" id="track-2"></div></div>
                <div class="marquee-track-wrapper"><div class="marquee-track track-3" id="track-3"></div></div>
            `;

            const track1 = document.getElementById('track-1');
            const track2 = document.getElementById('track-2');
            const track3 = document.getElementById('track-3');

            function randomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            function createMarqueeItems(start, end, container) {
                for(let i=start; i<=end; i++) {
                    
                    // [구조 변경] Wrapper(위치) -> Item(디자인) -> Img
                    const wrapper = document.createElement('div');
                    wrapper.className = 'marquee-item-wrapper';

                    const div = document.createElement('div');
                    div.className = 'marquee-item';
                    
                    const h = randomInt(200, 320); 
                    wrapper.style.height = `${h}px`; // 높이는 래퍼에 지정

                    const mr = randomInt(300, 600);
                    wrapper.style.marginRight = `${mr}px`; // 간격도 래퍼에 지정

                    // [수정됨] 배치 범위 확장 (0~300 -> 0~550)
                    const mt = randomInt(0, 550); 
                    
                    // 초기 위치 설정 (Wrapper가 담당)
                    wrapper.style.transform = `translateY(${mt}px)`;
                    
                    const img = document.createElement('img');
                    const imgNum = ((i - 1) % 36) + 1; 
                    img.src = `assets/info_image/${imgNum}.png`;
                    img.alt = `Work ${imgNum}`;
                    
                    img.onerror = function() {
                        this.style.display = 'none';
                        div.style.backgroundColor = '#d0d0d5';
                        const w = Math.floor(h * (randomInt(8, 14) / 10)); 
                        div.style.width = `${w}px`;
                        div.innerText = `File?\n${imgNum}.png`; 
                        div.style.color = '#fff';
                        div.style.fontSize = '0.8rem';
                        div.style.fontWeight = '400';
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                        div.style.textAlign = 'center';
                        div.style.lineHeight = '1.2';
                    };

                    div.appendChild(img);
                    wrapper.appendChild(div); // 래퍼 안에 아이템 넣기
                    container.appendChild(wrapper); // 컨테이너에 래퍼 넣기
                }
            }

            createMarqueeItems(1, 12, track1);
            createMarqueeItems(13, 24, track2);
            createMarqueeItems(25, 36, track3); 

            function cloneContent(track) {
                const items = Array.from(track.children);
                items.forEach(item => {
                    const clone = item.cloneNode(true);
                    clone.setAttribute('aria-hidden', 'true');
                    // 이벤트 리스너는 클론되지 않으므로 델리게이션(상위 요소 이벤트 위임) 방식 사용이 적합
                    track.appendChild(clone);
                });
            }

            cloneContent(track1);
            cloneContent(track2);
            cloneContent(track3);
            
            // ===============================================
            // [NEW] Z-INDEX HOVER LOGIC (수정됨)
            // ===============================================
            // 마우스가 올라간 요소만 앞으로 가져오고, 트랙 전체는 건드리지 않음
            containerSection.addEventListener('mouseover', (e) => {
                const wrapper = e.target.closest('.marquee-item-wrapper');
                if (wrapper) {
                    // 1. 해당 아이템을 트랙 내에서 맨 앞으로
                    wrapper.style.zIndex = 5000;
                    
                    // [삭제됨] 트랙 전체를 앞으로 가져오는 코드를 삭제하여 
                    // 다른 이미지들이 덩달아 튀어나오는 현상 제거
                    // const trackWrapper = wrapper.closest('.marquee-track-wrapper');
                    // if (trackWrapper) trackWrapper.style.zIndex = 5000;
                }
            });

            containerSection.addEventListener('mouseout', (e) => {
                const wrapper = e.target.closest('.marquee-item-wrapper');
                if (wrapper) {
                    // 1. 아이템 z-index 초기화
                    wrapper.style.zIndex = '';
                    
                    // [삭제됨] 트랙 z-index 복구 코드 삭제
                }
            });

            // ===============================================
            // [DRAG & DROP LOGIC] (Updated for Wrapper)
            // ===============================================
            let isDragging = false;
            let dragItem = null; // 이것은 이제 wrapper가 됩니다.
            let startX = 0, startY = 0;
            let initialItemX = 0, initialItemY = 0;
            let startTrackX = 0; 
            let dragTrack = null;

            containerSection.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', onDrag);
            window.addEventListener('mouseup', endDrag);
            
            containerSection.addEventListener('touchstart', (e) => startDrag(e.touches[0]));
            window.addEventListener('touchmove', (e) => onDrag(e.touches[0]));
            window.addEventListener('touchend', endDrag);

            function getTranslateX(el) {
                const style = window.getComputedStyle(el);
                const matrix = new WebKitCSSMatrix(style.transform);
                return matrix.m41;
            }

            function startDrag(e) {
                const target = e.target || e; 
                // [수정] 래퍼를 찾습니다
                const item = target.closest('.marquee-item-wrapper');
                if (!item) return;

                isDragging = true;
                dragItem = item;
                dragTrack = item.closest('.marquee-track');
                item.classList.add('dragging');

                startX = e.clientX;
                startY = e.clientY;

                const style = window.getComputedStyle(item);
                const matrix = new WebKitCSSMatrix(style.transform);
                initialItemX = matrix.m41;
                initialItemY = matrix.m42;

                startTrackX = getTranslateX(dragTrack);
            }

            function onDrag(e) {
                if (!isDragging || !dragItem) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                const currentTrackX = getTranslateX(dragTrack);
                const trackDiff = currentTrackX - startTrackX; 

                let newX = initialItemX + dx - trackDiff;
                let newY = initialItemY + dy;

                const itemHeight = dragItem.offsetHeight; 
                const sectionHeight = containerSection.clientHeight; 

                const topLimit = 50; 
                if (newY < topLimit) {
                     newY = topLimit; 
                }
                
                const bottomLimit = sectionHeight - itemHeight - 50;
                if (newY > bottomLimit) {
                     newY = bottomLimit; 
                }

                dragItem.style.transform = `translate(${newX}px, ${newY}px)`;
                // scale은 CSS가 처리하도록 둡니다 (transform 속성을 분리할 수 없으므로 JS에선 translate만)
                // 단, dragging 클래스가 붙으면 CSS에서 scale(1.05)를 덮어씁니다.
            }

            function endDrag() {
                if (isDragging && dragItem) {
                    dragItem.classList.remove('dragging');
                }
                isDragging = false;
                dragItem = null;
                dragTrack = null;
            }

        })();
    </script>
</body>
</html>