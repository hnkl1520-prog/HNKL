<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HNKL Portfolio</title>
    
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />
    <!-- GSAP for Preloader Animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <style>
        /* * Project HNKL Design System Variables */
        :root {
            --color-main-blue: #2b50f1;
            --color-purple: #9c6dff;
            --color-white: #ffffff;
            --color-mint: #4fd1c5;
            --bg-color: #F5F5F7;
            --text-color: #1a1a1a;
        }

        /* 1. 기본 커서 및 설정 */
        body, html { 
            margin: 0; padding: 0; overflow: hidden; 
            background-color: var(--bg-color); 
            font-family: 'Pretendard', sans-serif; 
            width: 100vw; height: 100vh; 
            cursor: default; 
        }

        .menu-item, .win-btn, #chat-minimized-icon, button, .send-btn { cursor: pointer; }

        /* * 2. PRELOADER STYLES (NEW) * */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            z-index: 10000; /* 커서(9999)보다 높게 설정 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .logo-container {
            position: relative;
            /* [수정] 로고 크기 */
            width: 240px; 
            height: 240px;
        }

        /* 공통 로고 스타일 */
        .logo-img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* 비율 유지하며 맞춤 */
        }

        /* Layer 1: 배경 (연한 로고) */
        .logo-bg {
            opacity: 0.2; /* 연하게 처리 (회색조 느낌) */
            filter: grayscale(100%); 
        }

        /* Layer 2: 채워지는 로고 (클리핑 마스크) */
        .logo-fill-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* 아래에서 위로 차오르는 효과 */
            clip-path: inset(100% 0 0 0); 
            /* [수정] 부드러운 움직임을 위해 CSS transition 제거 (JS로 직접 제어) */
            /* transition: clip-path 0.1s linear; */ 
        }
        
        /* 전경 이미지는 원본 색상 그대로 표시 */
        .logo-fg {
            opacity: 1;
        }

        /* [삭제] .progress-text 스타일 삭제됨 */

        /* 커서 팔로워 스타일 */
        #cursor-follower {
            position: fixed; top: 0; left: 0;
            width: 40px; height: 40px;
            background-color: rgba(0, 0, 0, 0); 
            border: 1.5px solid #898989; 
            border-radius: 50%;
            pointer-events: none; z-index: 9999;
            transform: translate(-50%, -50%);
            transition: width 0.3s cubic-bezier(0.19, 1, 0.22, 1),
                        height 0.3s cubic-bezier(0.19, 1, 0.22, 1),
                        background-color 0.3s, border-color 0.3s;
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }

        #cursor-text { font-size: 14px; font-weight: 500; color: white; opacity: 0; white-space: nowrap; transition: opacity 0.2s; letter-spacing: 0.05em; }

        /* active-enter, active-chat 클래스가 붙으면 커서가 커짐 */
        #cursor-follower.active-enter, #cursor-follower.active-chat {
            width: 80px; height: 80px;
            background-color: rgba(29, 29, 31, 0.6); 
            border-color: transparent; 
        }

        /* 텍스트 투명도 조절: active-chat일 때만 글씨 보임 */
        #cursor-follower.active-chat #cursor-text { opacity: 1; }
        
        /* active-enter(메뉴/버튼)일 때는 글씨 숨김 (커서만 커짐) */
        #cursor-follower.active-enter #cursor-text { opacity: 0; }

        /* 레이아웃 */
        .grid-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding: 0 120px; box-sizing: border-box;
            display: grid; grid-template-columns: repeat(12, 1fr); column-gap: 24px;
            pointer-events: none; z-index: 10; align-content: start; 
        }
        .grid-col { background-color: rgba(255, 0, 0, 0.0); height: 100%; }

        .menu-wrapper { grid-column: 1 / span 4; align-self: start; margin-top: 120px; pointer-events: auto; }
        .menu-item { width: fit-content; font-size: clamp(2rem, 3vw, 3rem); font-weight: 700; line-height: 1.1; margin-bottom: 12px; color: #1D1D1F; transition: opacity 0.3s; letter-spacing: -0.02em; }
        .menu-item:hover { opacity: 0.5; }

        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }

        /* 챗봇 UI */
        #chat-interface {
            display: none; 
            position: absolute; 
            bottom: 40px; right: 40px; 
            width: 360px; height: 500px;
            background: rgba(255, 255, 255, 0.95); border-radius: 24px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            z-index: 100; flex-direction: column; overflow: hidden; border: 1px solid rgba(0,0,0,0.05);
            animation: popUp 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popUp { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .chat-header { background: linear-gradient(90deg, #2b50f1, #9c6dff); padding: 15px 20px; color: white; font-weight: 700; display: flex; justify-content: space-between; align-items: center; }
        .chat-controls { display: flex; gap: 10px; align-items: center; }
        .win-btn { cursor: pointer; opacity: 0.7; font-size: 1.2rem; transition: opacity 0.2s; }
        .win-btn:hover { opacity: 1; }
        .chat-body { flex: 1; padding: 20px; overflow-y: auto; font-size: 0.9rem; }
        .message { margin-bottom: 12px; padding: 10px 14px; border-radius: 14px; max-width: 80%; line-height: 1.4; width: fit-content;}
        .bot { background: #F0F0F5; color: #333; align-self: flex-start; border-bottom-left-radius: 2px; }
        .user { background: #2b50f1; color: white; align-self: flex-end; margin-left: auto; border-bottom-right-radius: 2px; }
        .chat-input-area { padding: 15px; border-top: 1px solid #eee; display: flex; gap: 10px; }
        .chat-input { flex: 1; border: 1px solid #ddd; border-radius: 20px; padding: 10px 15px; outline: none; font-family: 'Pretendard'; }
        .send-btn { background: #2b50f1; color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; display: flex; align-items: center; justify-content: center; }

        #chat-minimized-icon {
            display: none; position: absolute; bottom: 40px; right: 40px; width: 60px; height: 60px;
            background: #2b50f1; border-radius: 50%; box-shadow: 0 5px 20px rgba(43, 80, 241, 0.4);
            z-index: 100; cursor: pointer; align-items: center; justify-content: center; font-size: 1.8rem; color: white;
            transition: transform 0.2s; animation: bounceIn 0.3s;
        }
        #chat-minimized-icon:hover { transform: scale(1.1); }
        @keyframes bounceIn { from { transform: scale(0); } to { transform: scale(1); } }

        #chat-minimized-icon img {
            width: 36px !important; 
            height: 36px !important;
            object-fit: contain; 
        }
        
        #chat-minimized-icon:hover .svg-main {
            transform: scale(1.1);
        }
        
        .svg-icon {
            width: 20px; height: 20px; display: block;
        }
        .svg-main {
            transition: transform 0.2s;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 2px;
            min-height: 20px;
            padding-top: 5px;
        }
        .typing-indicator span {
            height: 10px;
            width: 10px;
            float: left;
            margin: 0 2px;
            background-color: #9E9EA1;
            display: block;
            border-radius: 50%;
            opacity: 0.4;
            animation: loading 1s infinite alternate;
        }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes loading {
            from { transform: translateY(0px); }
            to { transform: translateY(-8px); }
        }

    
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- 1. LOADING SCREEN (Inserted Here) -->
    <div id="preloader">
        <div class="logo-container">
            <!-- [STEP 1] 배경 로고 (연한 색): 여기에 가지고 계신 svg 파일 경로를 입력하세요 -->
            <!-- 예: <img src="images/my-logo-outline.svg" ... > -->
            <img src="assets/logo_line.svg" class="logo-img logo-bg" alt="Logo Background">

            <!-- [STEP 2] 채워지는 로고 (진한 색): 안쪽이 꽉 찬(Filled) 로고 파일이 있다면 여기에 해당 파일 경로를 넣으세요! -->
            <div class="logo-fill-wrapper" id="fillMask">
                <img src="assets/logo.svg" class="logo-img logo-fg" alt="Logo Foreground">
            </div>
        </div>
        
        <!-- [삭제] progress-text 영역 삭제 -->
    </div>

    <!-- 2. Existing Content -->
    <div id="cursor-follower">
        <span id="cursor-text"></span>
    </div>

    <div class="grid-container">
        <div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div>
        <div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div>
        <div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div>

        <div class="menu-wrapper">
            <div class="menu-item link-item" onclick="location.href='about.html'">ABOUT</div>
            <div class="menu-item link-item" onclick="location.href='works.html'">WORKS</div>
        </div>
    </div>

    <div id="chat-interface" onmouseenter="setCursorDefault()" onmouseleave="setCursorActive()">
        <div class="chat-header">
            <span>HNKL AI</span>
            <div class="chat-controls">
                <span class="win-btn" onclick="minimizeChat()" title="최소화">
                    <img src="assets/Min_2.svg" alt="최소화" class="svg-icon">
                </span>
                <span class="win-btn" onclick="closeChat()" title="닫기">
                    <img src="assets/Close_2.svg" alt="닫기" class="svg-icon">    
                </span>
            </div>
        </div>
        <div class="chat-body" id="chat-body">
            <div class="message bot">안녕하세요! 저는 이 사이트의 AI 도우미입니다. 궁금한 점을 물어보세요.</div>
            <div class="message bot" id="loading-message" style="display: none;">
                <div class="typing-indicator">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div class="chat-input-area">
            <input type="text" class="chat-input" id="chat-input" placeholder="질문을 입력하세요..." onkeypress="if(event.key==='Enter') sendMessage()">
            <button class="send-btn" onclick="sendMessage()">
                <img src="assets/Send_2.svg" alt="보내기" class="svg-icon">
            </button>
        </div>
    </div>

    <div id="chat-minimized-icon" onclick="restoreChat()">
        <img src="assets/Chat_2.svg" alt="채팅" class="svg-main">
    </div>

    <div id="canvas-container"></div>

    <!-- Preloader Logic Script -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fillMask = document.getElementById('fillMask');
            const preloader = document.getElementById('preloader');
            
            let currentProgress = 0;
            
            // [속도 조절] 이 값을 변경하세요 (클수록 빠름, 작을수록 느리고 부드러움)
            const loadingSpeed = 1.5; 

            // 시뮬레이션 로딩 함수 (Three.js 로딩과 별개로 UI 애니메이션 실행)
            function simulateLoading() {
                // 이전의 불규칙한 랜덤 값 대신 고정된 값을 사용하여 부드럽게(Smooth) 처리
                currentProgress += loadingSpeed;

                if (currentProgress >= 100) {
                    currentProgress = 100;
                    updateLoader(100);
                    setTimeout(finishLoading, 500);
                } else {
                    updateLoader(currentProgress);
                    requestAnimationFrame(simulateLoading);
                }
            }

            function updateLoader(percent) {
                // 텍스트 업데이트 부분 삭제됨
                const insetBottom = 100 - percent;
                fillMask.style.clipPath = `inset(${insetBottom}% 0 0 0)`;
            }

            function finishLoading() {
                // GSAP를 사용하여 Preloader 페이드 아웃
                gsap.to(preloader, {
                    opacity: 0,
                    duration: 0.8,
                    ease: "power2.inOut",
                    onComplete: () => {
                        preloader.style.display = 'none';
                        // Three.js 씬이 뒤에서 이미 렌더링 되고 있음
                    }
                });
            }

            // 시작
            requestAnimationFrame(simulateLoading);
        });
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xF5F5F7); 

        const camera = new THREE.PerspectiveCamera(8, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 75); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const params = {
            color1: '#2b50f1', color2: '#9c6dff', color3: '#ffffff', color4: '#4fd1c5', color5: '#2b50f1',
            speed: 0.2, scale: 0.006, offset: 0.8, baseRotX: 90.0, baseRotY: 0.0, baseRotZ: 0.0 
        };

        const depthMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uColor1: { value: new THREE.Color(params.color1) },
                uColor2: { value: new THREE.Color(params.color2) },
                uColor3: { value: new THREE.Color(params.color3) },
                uColor4: { value: new THREE.Color(params.color4) },
                uColor5: { value: new THREE.Color(params.color5) },
                uTime: { value: 0 },
                uScale: { value: params.scale },
                uOffset: { value: params.offset },
                uRotX: { value: params.baseRotX },
                uRotY: { value: params.baseRotY },
                uRotZ: { value: params.baseRotZ }
            },
            vertexShader: `
                uniform float uRotX; uniform float uRotY; uniform float uRotZ;
                varying float vPos; 
                mat3 rotateX(float angle) { float s = sin(angle); float c = cos(angle); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }
                mat3 rotateY(float angle) { float s = sin(angle); float c = cos(angle); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }
                mat3 rotateZ(float angle) { float s = sin(angle); float c = cos(angle); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }
                void main() {
                    float rx = radians(uRotX); float ry = radians(uRotY); float rz = radians(uRotZ);
                    vec3 transformedPos = position;
                    transformedPos = rotateX(rx) * rotateY(ry) * rotateZ(rz) * transformedPos;
                    vPos = transformedPos.y;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 uColor1; uniform vec3 uColor2; uniform vec3 uColor3; uniform vec3 uColor4; uniform vec3 uColor5;
                uniform float uTime; uniform float uScale; uniform float uOffset;
                varying float vPos;
                void main() {
                    float t = fract((vPos * uScale) + uOffset - uTime);
                    vec3 finalColor;
                    if (t < 0.25) { finalColor = mix(uColor1, uColor2, t * 4.0); } 
                    else if (t < 0.5) { finalColor = mix(uColor2, uColor3, (t - 0.25) * 4.0); } 
                    else if (t < 0.75) { finalColor = mix(uColor3, uColor4, (t - 0.5) * 4.0); } 
                    else { finalColor = mix(uColor4, uColor5, (t - 0.75) * 4.0); }
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.75);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 4.5);
        dirLight.position.set(20, 41.05, 15); 
        dirLight.castShadow = true; dirLight.shadow.radius = 50; 
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048; 
        dirLight.shadow.camera.top = 30; dirLight.shadow.camera.bottom = -30; 
        dirLight.shadow.camera.left = -30; dirLight.shadow.camera.right = 30; dirLight.shadow.camera.far = 100; 
        scene.add(dirLight);
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.104, color: 0x000000 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2; plane.position.y = -3.5; plane.receiveShadow = true;
        scene.add(plane);

        let character = null;
        const baseScale = 1.25; 
        const groundY = -3;

        // [GLB Loader Restored]
        const loader = new GLTFLoader();
        loader.load('model_2.glb', function (gltf) {
            character = gltf.scene;
            character.scale.set(baseScale, baseScale, baseScale);
            character.position.y = groundY;
            character.traverse(function (node) {
                if (node.isMesh) { node.material = depthMaterial; node.castShadow = true; }
            });
            scene.add(character);
        }, undefined, function (error) {
            console.error('An error happened while loading the model:', error);
        });

        const particles = [];
        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 64, 64);
            ctx.beginPath(); ctx.arc(32, 32, 28, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }
        const circleTexture = createCircleTexture();
        const particleMaterialBase = new THREE.SpriteMaterial({ map: circleTexture, transparent: true, opacity: 1.0 });

        const baseColors = [new THREE.Color(params.color1), new THREE.Color(params.color2), new THREE.Color(params.color3), new THREE.Color(params.color4), new THREE.Color(params.color5)];

        function spawnParticle(position, velocityX, currentTime) {
            const material = particleMaterialBase.clone();
            material.color.copy(baseColors[Math.floor(Math.random() * baseColors.length)]);
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            const offset = 0.8;
            if (velocityX > 0) { sprite.position.x -= offset; } else { sprite.position.x += offset; }
            sprite.position.y += 0.5; sprite.position.z -= 0.5; 
            const scale = 0.3 + Math.random() * 0.3;
            sprite.scale.set(scale, scale, scale);
            const velocity = new THREE.Vector3(-velocityX * 0.5 + (Math.random() - 0.5) * 0.1, Math.random() * 0.05, -0.05 - Math.random() * 0.05);
            particleGroup.add(sprite);
            particles.push({ sprite, velocity, life: 1.0, material }); 
        }

        let mouseX = 0; let mouseY = 0;
        let pixelMouseX = 0; let pixelMouseY = 0;
        let currentX = 0; let velocityX = 0;
        const baseTension = 0.001; let tension = baseTension; const friction = 0.93;
        let currentRotX = params.baseRotX; let currentRotY = params.baseRotY;

        let isJumping = false; let isSquashing = false; let isLanding = false;
        let velocityY = 0; const gravity = -0.025; const jumpPower = 0.45; const bounceDamping = 0.3; 
        let landingTimer = null;

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        const cursorFollower = document.getElementById('cursor-follower');
        const cursorText = document.getElementById('cursor-text');
        let followerX = 0; let followerY = 0;
        
        let isHoveringLink = false;
        let isHoveringBall = false;
        let isHoveringButton = false;

        window.addEventListener('pointerdown', (event) => {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);

            let clickedBall = false;
            if (character) {
                const intersects = raycaster.intersectObject(character, true);
                if (intersects.length > 0) { clickedBall = true; }
            }

            if (clickedBall) {
                const chatUI = document.getElementById('chat-interface');
                const minIcon = document.getElementById('chat-minimized-icon');
                if (chatUI.style.display === 'none' && minIcon.style.display === 'none') { toggleChat(true); } 
                else { restoreChat(); }
            } else {
                if (!isJumping && !isSquashing && !isLanding) { isSquashing = true; }
            }
        });

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            pixelMouseX = event.clientX;
            pixelMouseY = event.clientY;
        });

        const linkItems = document.querySelectorAll('.link-item');
        linkItems.forEach(item => {
            item.addEventListener('mouseenter', () => { isHoveringLink = true; updateCursorState(); });
            item.addEventListener('mouseleave', () => { isHoveringLink = false; updateCursorState(); });
        });

        const chatIcon = document.getElementById('chat-minimized-icon');
        chatIcon.addEventListener('mouseenter', () => { isHoveringButton = true; updateCursorState(); });
        chatIcon.addEventListener('mouseleave', () => { isHoveringButton = false; updateCursorState(); });

        // [핵심 수정] 상태별 커서 모양 및 텍스트 정의
        function updateCursorState() {
            cursorFollower.classList.remove('active-enter', 'active-chat');
            cursorText.innerText = "";
            
            if (isHoveringBall) {
                // 공: 커서 커짐(O) + 텍스트 "CHAT"(O)
                cursorFollower.classList.add('active-chat');
                cursorText.innerText = "CHAT";
            } 
            else if (isHoveringLink || isHoveringButton) {
                // 메뉴/버튼: 커서 커짐(O) + 텍스트(X)
                cursorFollower.classList.add('active-enter');
                cursorText.innerText = ""; // 텍스트 없음
            }
        }
        
        window.setCursorDefault = function() { }
        window.setCursorActive = function() { }

        window.closeChat = function() { document.getElementById('chat-interface').style.display = 'none'; document.getElementById('chat-minimized-icon').style.display = 'none'; }
        window.minimizeChat = function() { document.getElementById('chat-interface').style.display = 'none'; document.getElementById('chat-minimized-icon').style.display = 'flex'; }
        window.restoreChat = function() { document.getElementById('chat-interface').style.display = 'flex'; document.getElementById('chat-minimized-icon').style.display = 'none'; }
        window.toggleChat = function(show) { if (show) restoreChat(); else closeChat(); }

        /* ▼ 324번째 줄 근처 sendMessage 함수 수정 */
        window.sendMessage = async function() {
            const input = document.getElementById('chat-input');
            const body = document.getElementById('chat-body');
            const text = input.value.trim();
            
            if (!text) return;

            // 1. 내 질문 표시
            body.innerHTML += `<div class="message user">${text}</div>`;
            input.value = '';
            body.scrollTop = body.scrollHeight;

            // 2. 로딩 말풍선 켜기! (이름이 loading-message로 바뀜)
            const loadingMessage = document.getElementById('loading-message');
            loadingMessage.style.display = 'block'; // flex 대신 block이나 inherit 추천
            body.appendChild(loadingMessage); // 로딩바를 맨 아래로 내리기
            body.scrollTop = body.scrollHeight;

            try {
                // 3. AI 답변 기다리기
                const responseText = await callGeminiAPI(text);

                // 4. 로딩 말풍선 끄기
                loadingMessage.style.display = 'none';

                // 5. 답변 표시
                body.innerHTML += `<div class="message bot">${responseText}</div>`;
                body.scrollTop = body.scrollHeight;

                // (중요) 로딩 말풍선을 다시 채팅창 맨 끝에 붙여둠 (다음 대화 준비)
                body.appendChild(loadingMessage);

            } catch (error) {
                // 에러 시 끄기
                loadingMessage.style.display = 'none';
                body.appendChild(loadingMessage);
            }
        }



       /* ▼ [배포용 수정] 서버 통신 함수 */
        async function callGeminiAPI(prompt) {
            try {
                // [중요] 배포 완료! 실제 Firebase 서버 주소로 변경했습니다.
                const apiUrl = 'https://us-central1-hnkl-49a5f.cloudfunctions.net/chat'; 

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: prompt }) 
                });

                if (!response.ok) {
                   // 403, 500 등 에러 발생 시 처리
                   throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                // 2. 답변 꺼내기
                if (data.candidates && data.candidates.length > 0) {
                    return data.candidates[0].content.parts[0].text;
                } else {
                    return "죄송해요, 답변을 못 들었어요.";
                }

            } catch (error) {
                console.error("통신 에러:", error);
                return `오류가 발생했습니다: ${error.message}. (관리자에게 문의하세요)`;
            }
        }



        const clock = new THREE.Clock();
        const lookRange = 45; 
        const lerp = (start, end, amt) => (1 - amt) * start + amt * end;

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            followerX += (pixelMouseX - followerX) * 0.5;
            followerY += (pixelMouseY - followerY) * 0.5;
            cursorFollower.style.transform = `translate(${followerX}px, ${followerY}px) translate(-50%, -50%)`;

            if (character) {
                pointer.x = mouseX; pointer.y = mouseY; 
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(character, true);
                const isIntersecting = intersects.length > 0;
                if (isIntersecting !== isHoveringBall) {
                    isHoveringBall = isIntersecting;
                    updateCursorState();
                }
            }

            const currentTime = depthMaterial.uniforms.uTime.value += delta * params.speed;
            
            const targetRotY = mouseX * lookRange; 
            const targetRotX = params.baseRotX + (-mouseY * lookRange); 
            currentRotX += (targetRotX - currentRotX) * 0.03;
            currentRotY += (targetRotY - currentRotY) * 0.03;
            depthMaterial.uniforms.uRotX.value = currentRotX;
            depthMaterial.uniforms.uRotY.value = currentRotY;

            if (character) {
                if (isSquashing) {
                    character.scale.y = lerp(character.scale.y, baseScale * 0.5, 0.4);
                    character.scale.x = lerp(character.scale.x, baseScale * 1.5, 0.4);
                    character.scale.z = lerp(character.scale.z, baseScale * 1.5, 0.4);
                    if (character.scale.y <= baseScale * 0.6) { isSquashing = false; isJumping = true; velocityY = jumpPower; }
                } 
                else if (isJumping) {
                    velocityY += gravity; character.position.y += velocityY;
                    const stretchAmount = 1 + Math.abs(velocityY) * 0.8; const squashAmount = 1 / Math.sqrt(stretchAmount);
                    character.scale.y = lerp(character.scale.y, baseScale * stretchAmount, 0.3);
                    character.scale.x = lerp(character.scale.x, baseScale * squashAmount, 0.3);
                    character.scale.z = lerp(character.scale.z, baseScale * squashAmount, 0.3);
                    if (character.position.y <= groundY) {
                        character.position.y = groundY;
                        if (Math.abs(velocityY) > 0.1) { velocityY = -velocityY * bounceDamping; character.scale.y = baseScale * 0.8; character.scale.x = baseScale * 1.2; character.scale.z = baseScale * 1.2; } 
                        else {
                            isJumping = false; velocityY = 0; character.scale.set(baseScale * 1.3, baseScale * 0.7, baseScale * 1.3);
                            isLanding = true; tension = baseTension * 1.5; 
                            if (landingTimer) clearTimeout(landingTimer);
                            landingTimer = setTimeout(() => { isLanding = false; tension = baseTension; }, 500);
                        }
                    }
                } else {
                    character.scale.y = lerp(character.scale.y, baseScale, 0.3);
                    character.scale.x = lerp(character.scale.x, baseScale, 0.3);
                    character.scale.z = lerp(character.scale.z, baseScale, 0.3);
                }

                if (!isJumping || isLanding) {
                    const targetX = mouseX;
                    const acceleration = (targetX - currentX) * tension;
                    velocityX += acceleration;
                }
                velocityX *= (isJumping && !isLanding) ? 0.99 : friction;
                currentX += velocityX;
                character.position.x = currentX * 10.0;
                if (!isJumping) { character.rotation.z = -currentX * Math.PI * 4; }

                if (Math.abs(velocityX) > 0.005 && !isJumping) {
                    if (Math.random() > 0.9) {
                        spawnParticle(character.position, velocityX, currentTime);
                    }
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.sprite.position.add(p.velocity); 
                p.sprite.scale.multiplyScalar(0.96); 
                p.life -= 0.02;
                if (p.sprite.scale.x < 0.05 || p.life <= 0) {
                    particleGroup.remove(p.sprite);
                    p.material.dispose();
                    particles.splice(i, 1);
                }
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>