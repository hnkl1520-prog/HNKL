<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HNKL Portfolio</title>
    
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />
    <!-- [필수] GSAP 추가 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <style>
        /* * Project HNKL Design System Variables */
        :root {
            --color-main-blue: #2b50f1;
            --color-purple: #9c6dff;
            --color-white: #ffffff;
            --color-mint: #4fd1c5;
            --color-bg: #F5F5F7; 
            --text-color: #1a1a1a;
        }

        /* 1. 기본 커서 및 설정 */
        body, html { 
            margin: 0; padding: 0; overflow: hidden; 
            background-color: var(--color-bg); 
            font-family: 'Pretendard', sans-serif; 
            width: 100vw; height: 100vh; 
            cursor: default; 
        }

        .menu-item, .win-btn, #chat-minimized-icon, button, .send-btn { cursor: pointer; }

        /* [NEW] 페이지 전환용 검은 커튼 */
        #transition-curtain {
            position: fixed;
            top: -100%; /* 위에서 대기 */
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 20000; /* 최상단 */
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none; 
        }
        
        .transition-text {
            color: white;
            font-size: 1.5rem;
            font-weight: 300;
            opacity: 0;
        }

        /* 커서 팔로워 스타일 */
        #cursor-follower {
            position: fixed; top: 0; left: 0;
            width: 0; height: 0; 
            z-index: 9999;
            pointer-events: none;
            will-change: transform;
            display: flex; align-items: center; justify-content: center;
        }

        #cursor-circle {
            position: absolute;
            width: 40px; height: 40px;
            background-color: rgba(0, 0, 0, 0);
            border: 1.5px solid #898989;
            border-radius: 50%;
            transform-origin: center center;
            transition: width 0.3s cubic-bezier(0.19, 1, 0.22, 1),
                        height 0.3s cubic-bezier(0.19, 1, 0.22, 1),
                        background-color 0.3s, border-color 0.3s;
            top: -20px; left: -20px;
        }

        #cursor-text { 
            position: absolute; 
            font-size: 14px; font-weight: 500; color: white; 
            opacity: 0; white-space: nowrap; 
            transition: opacity 0.2s; letter-spacing: 0.05em; 
            pointer-events: none;
            z-index: 10001; 
            transform: translate(-50%, -50%); 
            top: 0; left: 0;
        }

        #cursor-follower.active-enter #cursor-circle, 
        #cursor-follower.active-chat #cursor-circle {
            width: 80px; height: 80px;
            background-color: rgba(29, 29, 31, 0.6); 
            border-color: transparent; 
            top: -40px; left: -40px;
        }

        #cursor-follower.active-chat #cursor-text { opacity: 1; }
        #cursor-follower.active-enter #cursor-text { opacity: 0; }

        /* 레이아웃 */
        .grid-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding: 0 120px; box-sizing: border-box;
            display: grid; grid-template-columns: repeat(12, 1fr); column-gap: 24px;
            pointer-events: none; z-index: 10; align-content: start; 
        }
        .grid-col { background-color: rgba(255, 0, 0, 0.0); height: 100%; }

        .menu-wrapper { 
            grid-column: 1 / span 5; 
            align-self: start; 
            margin-top: 120px; 
            pointer-events: auto; 
        }

        /* [핵심 수정] 이중 레이어 텍스트 구조 */
        .reveal-container {
            position: relative;
            display: table; /* 텍스트 크기에 맞춤 */
            margin-bottom: 12px;
            cursor: pointer;
        }

        /* 공통 폰트 스타일 */
        .menu-text {
            font-size: clamp(2rem, 3vw, 3rem);
            font-weight: 700;
            line-height: 1.1;
            letter-spacing: -0.02em;
            display: block;
            padding: 10px 15px 10px 0; /* 박스 여유 공간 */
            transition: opacity 0.3s;
        }

        /* 1. 바닥층 (최종적으로 보일 검은색 텍스트) */
        .base-layer {
            color: #1a1a1a; /* 확실한 검은색 */
            position: relative;
            z-index: 1;
            opacity: 0; /* 처음엔 안 보임 (애니메이션 중간에 켜짐) */
        }

        /* 2. 덮개층 (애니메이션용 검은 박스 + 흰색 텍스트) */
        .overlay-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: #000000; /* 검은 박스 */
            color: #ffffff; /* 흰색 텍스트 */
            z-index: 2;
            overflow: hidden; /* 박스 크기만큼만 내용이 보임 */
            
            /* 초기 상태: 오른쪽 100%가 잘려서 안 보임 */
            clip-path: inset(0 100% 0 0); 
            pointer-events: none; /* 클릭은 바닥층이 받음 */
        }
        
        .overlay-text {
            position: absolute;
            top: 0; left: 0;
            width: 100%; /* 부모와 동일 너비 */
        }

        /* 마우스 오버 효과 */
        .reveal-container:hover .base-layer { opacity: 0.5; }

        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }

        /* 챗봇 UI */
        #chat-interface {
            display: none; 
            position: absolute; 
            bottom: 40px; right: 40px; 
            width: 360px; height: 500px;
            background: rgba(255, 255, 255, 0.95); border-radius: 24px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            z-index: 100; flex-direction: column; overflow: hidden; border: 1px solid rgba(0,0,0,0.05);
            animation: popUp 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popUp { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .chat-header { background: linear-gradient(90deg, #2b50f1, #9c6dff); padding: 15px 20px; color: white; font-weight: 700; display: flex; justify-content: space-between; align-items: center; }
        .chat-controls { display: flex; gap: 10px; align-items: center; }
        .win-btn { cursor: pointer; opacity: 0.7; font-size: 1.2rem; transition: opacity 0.2s; }
        .win-btn:hover { opacity: 1; }
        .chat-body { flex: 1; padding: 20px; overflow-y: auto; font-size: 0.9rem; }
        .message { margin-bottom: 12px; padding: 10px 14px; border-radius: 14px; max-width: 80%; line-height: 1.4; width: fit-content;}
        .bot { background: #F0F0F5; color: #333; align-self: flex-start; border-bottom-left-radius: 2px; }
        .user { background: #2b50f1; color: white; align-self: flex-end; margin-left: auto; border-bottom-right-radius: 2px; }
        .chat-input-area { padding: 15px; border-top: 1px solid #eee; display: flex; gap: 10px; }
        .chat-input { flex: 1; border: 1px solid #ddd; border-radius: 20px; padding: 10px 15px; outline: none; font-family: 'Pretendard'; }
        .send-btn { background: #2b50f1; color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; display: flex; align-items: center; justify-content: center; }

        #chat-minimized-icon {
            display: none; position: absolute; bottom: 40px; right: 40px; width: 60px; height: 60px;
            background: #2b50f1; border-radius: 50%; box-shadow: 0 5px 20px rgba(43, 80, 241, 0.4);
            z-index: 100; cursor: pointer; align-items: center; justify-content: center; font-size: 1.8rem; color: white;
            transition: transform 0.2s; animation: bounceIn 0.3s;
        }
        #chat-minimized-icon:hover { transform: scale(1.1); }
        @keyframes bounceIn { from { transform: scale(0); } to { transform: scale(1); } }

        #chat-minimized-icon img {
            width: 36px !important; 
            height: 36px !important;
            object-fit: contain; 
        }
        
        #chat-minimized-icon:hover .svg-main {
            transform: scale(1.1);
        }
        
        .svg-icon {
            width: 20px; height: 20px; display: block;
        }
        .svg-main {
            transition: transform 0.2s;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 2px;
            min-height: 20px;
            padding-top: 5px;
        }
        .typing-indicator span {
            height: 10px;
            width: 10px;
            float: left;
            margin: 0 2px;
            background-color: #9E9EA1;
            display: block;
            border-radius: 50%;
            opacity: 0.4;
            animation: loading 1s infinite alternate;
        }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes loading {
            from { transform: translateY(0px); }
            to { transform: translateY(-8px); }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- [NEW] TRANSITION CURTAIN (Only used for leaving page) -->
    <div id="transition-curtain">
        <div class="transition-text">Loading...</div>
    </div>

    <!-- Cursor Follower -->
    <div id="cursor-follower">
        <div id="cursor-circle"></div>
        <span id="cursor-text"></span>
    </div>

    <div class="grid-container">
        <div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div>
        <div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div>
        <div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div><div class="grid-col"></div>

        <div class="menu-wrapper">
            <!-- 
                [구조 변경] 2중 레이어 방식: Base(검정) + Overlay(검정박스/흰글씨) 
                - Base Layer: 실제 링크 역할 및 최종 검정 텍스트
                - Overlay Layer: 애니메이션 효과 담당 (pointer-events: none)
            -->
            
            <!-- 1. ABOUT -->
            <div class="reveal-container link-item" onclick="triggerPageTransition('about.html')">
                <!-- 바닥: 진짜 검정 텍스트 -->
                <div class="menu-text base-layer">ABOUT</div>
                <!-- 덮개: 검정 박스 + 흰 텍스트 -->
                <div class="overlay-layer">
                    <div class="menu-text overlay-text">ABOUT</div>
                </div>
            </div>
            
            <!-- 2. WORKS -->
            <div class="reveal-container link-item" onclick="triggerPageTransition('works.html')">
                <div class="menu-text base-layer">WORKS</div>
                <div class="overlay-layer">
                    <div class="menu-text overlay-text">WORKS</div>
                </div>
            </div>
        </div>
    </div>

    <div id="chat-interface" onmouseenter="setCursorDefault()" onmouseleave="setCursorActive()">
        <div class="chat-header">
            <span>HNKL AI</span>
            <div class="chat-controls">
                <span class="win-btn" onclick="minimizeChat()" title="최소화">
                    <img src="assets/Min_2.svg" alt="최소화" class="svg-icon">
                </span>
                <span class="win-btn" onclick="closeChat()" title="닫기">
                    <img src="assets/Close_2.svg" alt="닫기" class="svg-icon">    
                </span>
            </div>
        </div>
        <div class="chat-body" id="chat-body">
            <div class="message bot">안녕하세요! 저는 이 사이트의 AI 도우미입니다. 궁금한 점을 물어보세요.</div>
            <div class="message bot" id="loading-message" style="display: none;">
                <div class="typing-indicator">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        <div class="chat-input-area">
            <input type="text" class="chat-input" id="chat-input" placeholder="질문을 입력하세요..." onkeypress="if(event.key==='Enter') sendMessage()">
            <button class="send-btn" onclick="sendMessage()">
                <img src="assets/Send_2.svg" alt="보내기" class="svg-icon">
            </button>
        </div>
    </div>

    <div id="chat-minimized-icon" onclick="restoreChat()">
        <img src="assets/Chat_2.svg" alt="채팅" class="svg-main">
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xF5F5F7); 

        const camera = new THREE.PerspectiveCamera(8, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 75); 
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const params = {
            color1: '#2b50f1', color2: '#9c6dff', color3: '#ffffff', color4: '#4fd1c5', color5: '#2b50f1',
            speed: 0.2, scale: 0.006, offset: 0.8, baseRotX: 90.0, baseRotY: 0.0, baseRotZ: 0.0 
        };

        const depthMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uColor1: { value: new THREE.Color(params.color1) },
                uColor2: { value: new THREE.Color(params.color2) },
                uColor3: { value: new THREE.Color(params.color3) },
                uColor4: { value: new THREE.Color(params.color4) },
                uColor5: { value: new THREE.Color(params.color5) },
                uTime: { value: 0 },
                uScale: { value: params.scale },
                uOffset: { value: params.offset },
                uRotX: { value: params.baseRotX },
                uRotY: { value: params.baseRotY },
                uRotZ: { value: params.baseRotZ }
            },
            vertexShader: `
                uniform float uRotX; uniform float uRotY; uniform float uRotZ;
                varying float vPos; 
                mat3 rotateX(float angle) { float s = sin(angle); float c = cos(angle); return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); }
                mat3 rotateY(float angle) { float s = sin(angle); float c = cos(angle); return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c); }
                mat3 rotateZ(float angle) { float s = sin(angle); float c = cos(angle); return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0); }
                void main() {
                    float rx = radians(uRotX); float ry = radians(uRotY); float rz = radians(uRotZ);
                    vec3 transformedPos = position;
                    transformedPos = rotateX(rx) * rotateY(ry) * rotateZ(rz) * transformedPos;
                    vPos = transformedPos.y;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 uColor1; uniform vec3 uColor2; uniform vec3 uColor3; uniform vec3 uColor4; uniform vec3 uColor5;
                uniform float uTime; uniform float uScale; uniform float uOffset;
                varying float vPos;
                void main() {
                    float t = fract((vPos * uScale) + uOffset - uTime);
                    vec3 finalColor;
                    if (t < 0.25) { finalColor = mix(uColor1, uColor2, t * 4.0); } 
                    else if (t < 0.5) { finalColor = mix(uColor2, uColor3, (t - 0.25) * 4.0); } 
                    else if (t < 0.75) { finalColor = mix(uColor3, uColor4, (t - 0.5) * 4.0); } 
                    else { finalColor = mix(uColor4, uColor5, (t - 0.75) * 4.0); }
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.75);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 4.5);
        dirLight.position.set(20, 41.05, 15); 
        dirLight.castShadow = true; dirLight.shadow.radius = 50; 
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048; 
        dirLight.shadow.camera.top = 30; dirLight.shadow.camera.bottom = -30; 
        dirLight.shadow.camera.left = -30; dirLight.shadow.camera.right = 30; dirLight.shadow.camera.far = 100; 
        scene.add(dirLight);
        
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.104, color: 0x000000 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2; plane.position.y = -3.5; plane.receiveShadow = true;
        scene.add(plane);

        let character = null;
        const baseScale = 1.25; 
        const groundY = -3;
        
        const loader = new GLTFLoader();
        loader.load('model_2.glb', function (gltf) {
            character = gltf.scene;
            character.scale.set(baseScale, baseScale, baseScale);
            character.position.y = groundY; 
            character.traverse(function (node) {
                if (node.isMesh) { node.material = depthMaterial; node.castShadow = true; }
            });
            scene.add(character);
        }, undefined, function (error) {
            console.error('An error happened while loading the model:', error);
        });

        const particles = [];
        const particleGroup = new THREE.Group();
        scene.add(particleGroup);

        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 64, 64);
            ctx.beginPath(); ctx.arc(32, 32, 28, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }
        const circleTexture = createCircleTexture();
        const particleMaterialBase = new THREE.SpriteMaterial({ map: circleTexture, transparent: true, opacity: 1.0 });

        const baseColors = [new THREE.Color(params.color1), new THREE.Color(params.color2), new THREE.Color(params.color3), new THREE.Color(params.color4), new THREE.Color(params.color5)];

        function spawnParticle(position, velocityX, currentTime) {
            const material = particleMaterialBase.clone();
            material.color.copy(baseColors[Math.floor(Math.random() * baseColors.length)]);
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            const offset = 0.8;
            if (velocityX > 0) { sprite.position.x -= offset; } else { sprite.position.x += offset; }
            sprite.position.y += 0.5; sprite.position.z -= 0.5; 
            const scale = 0.3 + Math.random() * 0.3;
            sprite.scale.set(scale, scale, scale);
            const velocity = new THREE.Vector3(-velocityX * 0.5 + (Math.random() - 0.5) * 0.1, Math.random() * 0.05, -0.05 - Math.random() * 0.05);
            particleGroup.add(sprite);
            particles.push({ sprite, velocity, life: 1.0, material }); 
        }

        let mouseX = 0; let mouseY = 0;
        let pixelMouseX = window.innerWidth / 2; 
        let pixelMouseY = window.innerHeight / 2;
        let currentX = 0; let velocityX = 0;
        const baseTension = 0.002; let tension = baseTension; const friction = 0.93;
        let currentRotX = params.baseRotX; let currentRotY = params.baseRotY;

        let isJumping = false; let isSquashing = false; let isLanding = false;
        let velocityY = 0; const gravity = -0.025; const jumpPower = 0.45; const bounceDamping = 0.3; 
        let landingTimer = null;

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        const cursorFollower = document.getElementById('cursor-follower');
        const cursorCircle = document.getElementById('cursor-circle'); 
        const cursorText = document.getElementById('cursor-text');
        
        let cursorX = window.innerWidth / 2;
        let cursorY = window.innerHeight / 2;
        
        let isHoveringLink = false;
        let isHoveringBall = false;
        let isHoveringButton = false;

        let ignoreFloor = false;

        // [애니메이션] GSAP Reveal Logic - "Layer Masking" (Double Layer)
        // [수정사항] 초기 상태 0(안보임) -> 등장 애니메이션 -> 중간에 1로 셋팅
        function initIntroAnimation() {
            const tl = gsap.timeline({ 
                delay: 0.5, 
            });

            // 1. 초기에는 .base-layer를 보이지 않게 설정 (CSS와 JS 이중 안전장치)
            // 주의: 이전에 있던 'gsap.set opacity:1' 코드는 삭제됨.

            // ABOUT 애니메이션
            // Phase 1: 덮개(Overlay)가 나타남 (왼->오)
            // 이때 화면엔 검정 박스와 흰 글씨가 보임
            tl.to('.reveal-container:nth-child(1) .overlay-layer', {
                clipPath: 'inset(0 0% 0 0)',
                duration: 0.6,
                ease: 'power3.inOut'
            })
            // [중요] 박스가 글자를 다 덮었을 때, 바닥의 진짜 검은 글씨를 켜둠 (박스 뒤라 안 보임)
            .set('.reveal-container:nth-child(1) .base-layer', { opacity: 1 })
            
            // Phase 2: 덮개가 사라짐 (왼->오)
            // 박스가 사라지면서 미리 켜둔 바닥의 검은 글씨가 드러남
            .to('.reveal-container:nth-child(1) .overlay-layer', {
                clipPath: 'inset(0 0% 0 100%)',
                duration: 0.6,
                ease: 'power3.inOut'
            });

            // WORKS 애니메이션 (동일 로직)
            tl.to('.reveal-container:nth-child(2) .overlay-layer', {
                clipPath: 'inset(0 0% 0 0)',
                duration: 0.6,
                ease: 'power3.inOut'
            }, "-=0.4") // 약간 겹치게
            .set('.reveal-container:nth-child(2) .base-layer', { opacity: 1 })
            .to('.reveal-container:nth-child(2) .overlay-layer', {
                clipPath: 'inset(0 0% 0 100%)',
                duration: 0.6,
                ease: 'power3.inOut'
            });
        }

        // 페이지 로드 시 인트로 시작
        window.addEventListener('load', initIntroAnimation);

        window.triggerPageTransition = function(targetUrl) {
            if (!character) {
                location.href = targetUrl;
                return;
            }
            isJumping = true;
            isSquashing = false;
            isLanding = false;
            velocityY = 0.5; 
            ignoreFloor = true; 
            if (plane) plane.visible = false;

            const curtain = document.getElementById('transition-curtain');
            const transitionText = curtain.querySelector('.transition-text');
            
            gsap.to(curtain, {
                top: 0,
                duration: 0.6,
                ease: "power3.inOut",
                delay: 0.7,
                onComplete: () => {
                    window.location.href = targetUrl;
                }
            });

            gsap.to(transitionText, { opacity: 1, duration: 0.3, delay: 0.8 });
        };

        window.addEventListener('pointerdown', (event) => {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);

            let clickedBall = false;
            if (character) {
                const intersects = raycaster.intersectObject(character, true);
                if (intersects.length > 0) { clickedBall = true; }
            }

            if (clickedBall) {
                const chatUI = document.getElementById('chat-interface');
                const minIcon = document.getElementById('chat-minimized-icon');
                if (chatUI.style.display === 'none' && minIcon.style.display === 'none') { toggleChat(true); } 
                else { restoreChat(); }
            } else {
                if (!isJumping && !isSquashing && !isLanding) { isSquashing = true; }
            }
        });

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            pixelMouseX = event.clientX;
            pixelMouseY = event.clientY;
        });

        const linkItems = document.querySelectorAll('.link-item');
        linkItems.forEach(item => {
            item.addEventListener('mouseenter', () => { isHoveringLink = true; updateCursorState(); });
            item.addEventListener('mouseleave', () => { isHoveringLink = false; updateCursorState(); });
        });

        const chatIcon = document.getElementById('chat-minimized-icon');
        chatIcon.addEventListener('mouseenter', () => { isHoveringButton = true; updateCursorState(); });
        chatIcon.addEventListener('mouseleave', () => { isHoveringButton = false; updateCursorState(); });

        function updateCursorState() {
            cursorFollower.classList.remove('active-enter', 'active-chat');
            cursorText.innerText = "";
            
            if (isHoveringBall) {
                cursorFollower.classList.add('active-chat');
                cursorText.innerText = "CHAT";
            } 
            else if (isHoveringLink || isHoveringButton) {
                cursorFollower.classList.add('active-enter');
                cursorText.innerText = ""; 
            }
        }
        
        window.setCursorDefault = function() { }
        window.setCursorActive = function() { }

        window.closeChat = function() { document.getElementById('chat-interface').style.display = 'none'; document.getElementById('chat-minimized-icon').style.display = 'none'; }
        window.minimizeChat = function() { document.getElementById('chat-interface').style.display = 'none'; document.getElementById('chat-minimized-icon').style.display = 'flex'; }
        window.restoreChat = function() { document.getElementById('chat-interface').style.display = 'flex'; document.getElementById('chat-minimized-icon').style.display = 'none'; }
        window.toggleChat = function(show) { if (show) restoreChat(); else closeChat(); }

        window.sendMessage = async function() {
            const input = document.getElementById('chat-input');
            const body = document.getElementById('chat-body');
            const text = input.value.trim();
            
            if (!text) return;

            body.innerHTML += `<div class="message user">${text}</div>`;
            input.value = '';
            body.scrollTop = body.scrollHeight;

            const loadingMessage = document.getElementById('loading-message');
            loadingMessage.style.display = 'block'; 
            body.appendChild(loadingMessage); 
            body.scrollTop = body.scrollHeight;

            try {
                const responseText = await callGeminiAPI(text);
                loadingMessage.style.display = 'none';
                body.innerHTML += `<div class="message bot">${responseText}</div>`;
                body.scrollTop = body.scrollHeight;
                body.appendChild(loadingMessage);

            } catch (error) {
                loadingMessage.style.display = 'none';
                body.appendChild(loadingMessage);
            }
        }

        async function callGeminiAPI(prompt) {
            try {
                const apiUrl = 'https://us-central1-hnkl-49a5f.cloudfunctions.net/chat'; 
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: prompt }) 
                });
                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                const data = await response.json();
                if (data.candidates && data.candidates.length > 0) {
                    return data.candidates[0].content.parts[0].text;
                } else {
                    return "죄송해요, 답변을 못 들었어요.";
                }
            } catch (error) {
                console.error("통신 에러:", error);
                return `오류가 발생했습니다: ${error.message}. (관리자에게 문의하세요)`;
            }
        }

        const clock = new THREE.Clock();
        const lookRange = 45; 
        const lerp = (start, end, amt) => (1 - amt) * start + amt * end;

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            const ease = 0.2; 
            const nextX = cursorX + (pixelMouseX - cursorX) * ease;
            const nextY = cursorY + (pixelMouseY - cursorY) * ease;
            
            const velX = nextX - cursorX;
            const velY = nextY - cursorY;
            cursorX = nextX;
            cursorY = nextY;
            
            const dist = Math.sqrt(velX * velX + velY * velY);
            const angle = Math.atan2(velY, velX);
            const stretch = Math.min(dist * 0.1, 0.5);
            
            const scaleX = 1 + stretch;
            const scaleY = 1 - stretch * 0.4;
            
            cursorFollower.style.transform = `translate3d(${cursorX}px, ${cursorY}px, 0)`;
            cursorCircle.style.transform = `rotate(${angle}rad) scale(${scaleX}, ${scaleY})`;

            if (character) {
                pointer.x = mouseX; pointer.y = mouseY; 
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObject(character, true);
                const isIntersecting = intersects.length > 0;
                if (isIntersecting !== isHoveringBall) {
                    isHoveringBall = isIntersecting;
                    updateCursorState();
                }
            }

            const currentTime = depthMaterial.uniforms.uTime.value += delta * params.speed;
            
            const targetRotY = mouseX * lookRange; 
            const targetRotX = params.baseRotX + (-mouseY * lookRange); 
            currentRotX += (targetRotX - currentRotX) * 0.03;
            currentRotY += (targetRotY - currentRotY) * 0.03;
            depthMaterial.uniforms.uRotX.value = currentRotX;
            depthMaterial.uniforms.uRotY.value = currentRotY;

            if (character) {
                if (isSquashing) {
                    character.scale.y = lerp(character.scale.y, baseScale * 0.5, 0.4);
                    character.scale.x = lerp(character.scale.x, baseScale * 1.5, 0.4);
                    character.scale.z = lerp(character.scale.z, baseScale * 1.5, 0.4);
                    if (character.scale.y <= baseScale * 0.6) { isSquashing = false; isJumping = true; velocityY = jumpPower; }
                } 
                else if (isJumping) {
                    velocityY += gravity; 
                    character.position.y += velocityY;
                    
                    const stretchAmount = 1 + Math.abs(velocityY) * 0.8; 
                    const squashAmount = 1 / Math.sqrt(stretchAmount);
                    character.scale.y = lerp(character.scale.y, baseScale * stretchAmount, 0.3);
                    character.scale.x = lerp(character.scale.x, baseScale * squashAmount, 0.3);
                    character.scale.z = lerp(character.scale.z, baseScale * squashAmount, 0.3);
                    
                    if (!ignoreFloor && character.position.y <= groundY) {
                        character.position.y = groundY;
                        if (Math.abs(velocityY) > 0.1) { 
                            velocityY = -velocityY * bounceDamping; 
                            character.scale.y = baseScale * 0.8; 
                            character.scale.x = baseScale * 1.2; 
                            character.scale.z = baseScale * 1.2; 
                        } 
                        else {
                            isJumping = false; velocityY = 0; character.scale.set(baseScale * 1.3, baseScale * 0.7, baseScale * 1.3);
                            isLanding = true; tension = baseTension * 1.5; 
                            if (landingTimer) clearTimeout(landingTimer);
                            landingTimer = setTimeout(() => { isLanding = false; tension = baseTension; }, 500);
                        }
                    }
                } 
                else {
                    character.scale.y = lerp(character.scale.y, baseScale, 0.3);
                    character.scale.x = lerp(character.scale.x, baseScale, 0.3);
                    character.scale.z = lerp(character.scale.z, baseScale, 0.3);
                }

                if (!isJumping || isLanding) {
                    const targetX = mouseX;
                    const acceleration = (targetX - currentX) * tension;
                    velocityX += acceleration;
                }
                
                velocityX *= (isJumping && !isLanding) ? 0.99 : friction;
                currentX += velocityX;
                character.position.x = currentX * 10.0;
                
                if (!isJumping) { character.rotation.z = -currentX * Math.PI * 4; }

                if (Math.abs(velocityX) > 0.005 && !isJumping) {
                    if (Math.random() > 0.9) {
                        spawnParticle(character.position, velocityX, currentTime);
                    }
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.sprite.position.add(p.velocity); 
                p.sprite.scale.multiplyScalar(0.96); 
                p.life -= 0.02;
                if (p.sprite.scale.x < 0.05 || p.life <= 0) {
                    particleGroup.remove(p.sprite);
                    p.material.dispose();
                    particles.splice(i, 1);
                }
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>